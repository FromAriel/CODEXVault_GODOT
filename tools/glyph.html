<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UNSCII Glyph Browser + Editor (Single File)</title>
  <style>
    :root {
      --bg: #0f1117;
      --panel: #151a22;
      --panel2: #10141b;
      --text: #e6e6e6;
      --muted: #a7b0c0;
      --accent: #8a7dff;
      --accent2: #5eead4;
      --border: #2a3140;
      --danger: #ff5c7a;
      --ok: #43d19e;
      --shadow: 0 8px 30px rgba(0,0,0,.35);
      --radius: 14px;

      --split-left: 25%;
      --tile: 84px; /* dynamic; JS also uses */
      --tilePad: 10px;
      --glyphSize: 56px;
      --labelSize: 11px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 10% 0%, rgba(138,125,255,.18), transparent 60%),
                  radial-gradient(1100px 800px at 100% 30%, rgba(94,234,212,.12), transparent 55%),
                  var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    /* Top bar */
    .topbar {
      height: 64px;
      padding: 10px 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(21,26,34,.98), rgba(16,20,27,.96));
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 10;
    }

    .brand {
      display: flex;
      align-items: baseline;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: 0 0 0 1px rgba(138,125,255,.12) inset;
      user-select: none;
      white-space: nowrap;
    }
    .brand b {
      font-weight: 800;
      letter-spacing: .2px;
      color: #ffffff;
    }
    .brand small {
      color: var(--muted);
      font-size: 12px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }

    .group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      border-radius: 12px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
      min-width: 0;
    }

    .group.compact { padding: 6px; }
    .group .label {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      user-select: none;
    }

    input[type="file"] { display: none; }

    .btn {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 650;
      font-size: 13px;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      user-select: none;
      white-space: nowrap;
    }
    .btn:hover { background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.16); }
    .btn:active { transform: translateY(1px); }
    .btn.primary {
      border-color: rgba(138,125,255,.45);
      background: rgba(138,125,255,.18);
      box-shadow: 0 0 0 1px rgba(138,125,255,.22) inset;
    }
    .btn.danger {
      border-color: rgba(255,92,122,.35);
      background: rgba(255,92,122,.12);
    }
    .btn.ghost {
      background: transparent;
      border-color: rgba(255,255,255,.09);
    }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      user-select: none;
      max-width: 360px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .search {
      width: min(560px, 42vw);
      max-width: 100%;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
      min-width: 180px;
    }
    .search::placeholder { color: rgba(167,176,192,.75); }

    .range {
      width: 150px;
      accent-color: var(--accent);
    }
    .num {
      width: 64px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline: none;
      font-weight: 650;
      font-size: 13px;
    }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .toggle input { accent-color: var(--accent); }

    .select {
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      outline: none;
      font-size: 13px;
      min-width: 160px;
    }

    /* Main split */
    .main {
      height: calc(100% - 64px);
      display: flex;
      width: 100%;
      position: relative;
    }

    .pane {
      height: 100%;
      overflow: hidden;
      position: relative;
      min-width: 220px;
    }

    .left {
      width: var(--split-left);
      border-right: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(21,26,34,.85), rgba(16,20,27,.90));
    }
    .right {
      flex: 1;
      background: linear-gradient(180deg, rgba(16,20,27,.92), rgba(15,17,23,.96));
    }

    .divider {
      position: absolute;
      top: 0;
      bottom: 0;
      left: var(--split-left);
      width: 10px;
      transform: translateX(-5px);
      cursor: col-resize;
      z-index: 8;
    }
    .divider::before {
      content: "";
      position: absolute;
      top: 10px;
      bottom: 10px;
      left: 50%;
      width: 2px;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px rgba(138,125,255,.10);
      opacity: .7;
    }
    .divider:hover::before { opacity: 1; background: rgba(138,125,255,.55); }

    /* Left editor area */
    .editorWrap {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
    }

    .editorHeader {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.14);
      box-shadow: var(--shadow);
    }

    .editorHeader .mini {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .editorHeader .title {
      font-weight: 800;
      letter-spacing: .2px;
    }
    .editorHeader .sub {
      color: var(--muted);
      font-size: 12px;
      margin-left: 8px;
    }

    .editor {
      flex: 1;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.14);
      box-shadow: var(--shadow);
      overflow: auto;
      padding: 14px;
      outline: none;
      line-height: 1.35;
      font-size: 18px;
      white-space: pre-wrap;
      word-break: break-word;
      caret-color: var(--accent2);
      position: relative;
    }

    .dropHint {
      position: absolute;
      inset: 14px;
      border-radius: 12px;
      border: 1px dashed rgba(138,125,255,.35);
      background: rgba(138,125,255,.08);
      display: none;
      pointer-events: none;
    }
    .editor.dragOver .dropHint { display: block; }

    .status {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
      color: var(--muted);
      font-size: 12px;
    }

    /* Right glyph area */
    .glyphWrap {
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 10px;
    }

    .glyphHeader {
      display: flex;
      gap: 10px;
      align-items: stretch;
      flex-wrap: wrap;
    }

    .card {
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.14);
      box-shadow: var(--shadow);
      padding: 10px;
    }

    .infoGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .infoGrid b {
      color: var(--text);
      font-weight: 750;
    }
    .infoRow {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .glyphScroller {
      flex: 1;
      position: relative;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.10);
      box-shadow: var(--shadow);
      overflow: auto;
    }

    .spacer {
      position: relative;
      width: 100%;
    }

    .tileLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      will-change: transform;
      padding: 10px;
    }

    .tile {
      position: absolute;
      width: var(--tile);
      height: var(--tile);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
      transition: transform .06s ease, border-color .12s ease, background .12s ease;
      overflow: hidden;
    }
    .tile:hover {
      background: rgba(255,255,255,.05);
      border-color: rgba(138,125,255,.28);
      transform: translateY(-1px);
    }
    .tile.selected {
      border-color: rgba(94,234,212,.55);
      box-shadow: 0 0 0 1px rgba(94,234,212,.20) inset;
      background: rgba(94,234,212,.06);
    }

    .glyph {
      font-size: var(--glyphSize);
      line-height: 1;
      color: #fff;
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
      transform: translateY(1px);
    }
    .glabel {
      font-size: var(--labelSize);
      color: rgba(167,176,192,.92);
      font-weight: 650;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
    }

    .star {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      color: rgba(255,255,255,.75);
      opacity: .95;
    }
    .star.on {
      color: #fff;
      border-color: rgba(138,125,255,.45);
      background: rgba(138,125,255,.18);
      box-shadow: 0 0 0 1px rgba(138,125,255,.22) inset;
    }

    .badge {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 12px;
      user-select: none;
      white-space: nowrap;
    }
    .badge strong { color: var(--text); font-weight: 800; }

    .toast {
      position: fixed;
      bottom: 14px;
      left: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      box-shadow: var(--shadow);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events: none;
      z-index: 999;
      font-size: 13px;
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .muted { color: var(--muted); }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.85);
    }

    @media (max-width: 1100px) {
      .pill { display: none; }
      .search { width: 36vw; }
    }
    @media (max-width: 900px) {
      .main { flex-direction: column; }
      .left { width: 100% !important; height: 45%; border-right: 0; border-bottom: 1px solid var(--border); }
      .right { height: 55%; }
      .divider { display: none; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <b>GlyphLab</b>
      <small>TTF cmap + drag/drop editor</small>
    </div>

    <div class="controls">
      <div class="group">
        <label class="btn primary" for="fontFile">Load TTF…</label>
        <input id="fontFile" type="file" accept=".ttf,.otf,.ttc" />
        <span id="fontPill" class="pill">No font loaded (open a .ttf)</span>
      </div>

      <div class="group">
        <input id="search" class="search" placeholder="Search: U+2588, 2588, 2500-257F, or paste a glyph…" />
        <button id="clearSearch" class="btn ghost" title="Clear search">✕</button>
      </div>

      <div class="group compact">
        <span class="label">Glyph size</span>
        <input id="glyphSize" class="range" type="range" min="18" max="140" value="56" />
        <input id="glyphSizeNum" class="num" type="number" min="10" max="220" value="56" />
      </div>

      <div class="group compact">
        <span class="label">Tiles</span>
        <span class="toggle"><input id="showLabels" type="checkbox" checked /> Labels</span>
        <span class="toggle"><input id="showWhitespace" type="checkbox" /> Whitespace</span>
        <span class="toggle"><input id="showCombining" type="checkbox" checked /> Combining</span>
        <span class="toggle"><input id="showControls" type="checkbox" /> Controls</span>
      </div>

      <div class="group compact">
        <span class="label">Block</span>
        <select id="blockFilter" class="select" title="Quick range filters">
          <option value="all">All codepoints</option>
          <option value="favorites">★ Favorites</option>
          <option value="recent">⟲ Recent</option>
          <option value="ascii">ASCII (0020–007E)</option>
          <option value="latin1">Latin-1 Supplement (00A0–00FF)</option>
          <option value="box">Box Drawing (2500–257F)</option>
          <option value="block">Block Elements (2580–259F)</option>
          <option value="geom">Geometric Shapes (25A0–25FF)</option>
          <option value="braille">Braille Patterns (2800–28FF)</option>
          <option value="misc">Misc Symbols (2600–26FF)</option>
          <option value="pua_bmp">Private Use Area (E000–F8FF)</option>
          <option value="pua_p15">PUA Plane 15 (F0000–FFFFD)</option>
          <option value="pua_p16">PUA Plane 16 (100000–10FFFD)</option>
        </select>
      </div>

      <div class="group compact">
        <button id="copySelected" class="btn">Copy glyph</button>
        <button id="insertSelected" class="btn">Insert</button>
        <button id="starSelected" class="btn">★</button>
      </div>
    </div>
  </div>

  <div class="main" id="main">
    <div class="pane left" id="leftPane">
      <div class="editorWrap">
        <div class="editorHeader">
          <div>
            <span class="title">Editor</span>
            <span class="sub">Double-click or drag glyphs here</span>
          </div>
          <div class="mini">
            <button id="newDoc" class="btn ghost" title="New document">New</button>
            <button id="copyAll" class="btn ghost" title="Copy all text">Copy all</button>
            <button id="downloadText" class="btn primary" title="Download editor text">Download</button>
            <button id="clearEditor" class="btn danger" title="Clear editor">Clear</button>
          </div>
        </div>

        <div id="editor" class="editor" contenteditable="true" spellcheck="false">
          <div class="dropHint"></div>
          Type here… then drag or double-click glyphs from the grid on the right.
        </div>

        <div class="status">
          <div id="editorStats">Chars: 0 • Lines: 1</div>
          <div class="muted">
            Tips: <span class="kbd">Ctrl</span>+<span class="kbd">F</span> search •
            <span class="kbd">Ctrl</span>+<span class="kbd">S</span> download •
            <span class="kbd">Enter</span> insert selected glyph
          </div>
        </div>
      </div>
    </div>

    <div class="divider" id="divider" title="Drag to resize"></div>

    <div class="pane right" id="rightPane">
      <div class="glyphWrap">
        <div class="glyphHeader">
          <div class="card" style="flex: 1; min-width: 340px;">
            <div style="display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom: 10px;">
              <div class="badge"><strong id="glyphCount">0</strong> glyphs</div>
              <div class="badge">Selected: <strong id="selLabel">—</strong></div>
              <div class="badge">Font: <strong id="fontShort">—</strong></div>
            </div>
            <div class="infoGrid">
              <div class="infoRow"><span>Character</span><b id="infoChar" class="mono">—</b></div>
              <div class="infoRow"><span>Codepoint</span><b id="infoCode" class="mono">—</b></div>
              <div class="infoRow"><span>UTF-16</span><b id="infoUtf16" class="mono">—</b></div>
              <div class="infoRow"><span>UTF-8 bytes</span><b id="infoUtf8" class="mono">—</b></div>
              <div class="infoRow"><span>JS escape</span><b id="infoJs" class="mono">—</b></div>
              <div class="infoRow"><span>Python escape</span><b id="infoPy" class="mono">—</b></div>
              <div class="infoRow"><span>HTML entity</span><b id="infoHtml" class="mono">—</b></div>
              <div class="infoRow"><span>Category</span><b id="infoCat" class="mono">—</b></div>
            </div>
          </div>

          <div class="card" style="width: 360px; min-width: 300px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;">
              <div class="badge">★ Favorites: <strong id="favCount">0</strong></div>
              <div class="badge">⟲ Recent: <strong id="recentCount">0</strong></div>
            </div>

            <div style="display:flex; gap:10px; flex-wrap: wrap;">
              <button id="clearFavs" class="btn ghost" title="Clear favorites for this font">Clear favorites</button>
              <button id="clearRecents" class="btn ghost" title="Clear recent insert history">Clear recents</button>
              <button id="copyInfo" class="btn" title="Copy the selected glyph's info block">Copy info</button>
            </div>

            <div style="margin-top: 10px; color: var(--muted); font-size: 12px; line-height: 1.35;">
              This app reads your TTF locally, extracts supported Unicode codepoints from <span class="mono">cmap</span>, and renders
              a fast virtualized grid. It does not upload anything.
            </div>
          </div>
        </div>

        <div id="glyphScroller" class="glyphScroller">
          <div id="spacer" class="spacer"></div>
          <div id="tileLayer" class="tileLayer"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(() => {
  "use strict";

  // ---------------------------
  // Utilities
  // ---------------------------
  function clamp(n, lo, hi) {
    if (n < lo) return lo;
    if (n > hi) return hi;
    return n;
  }

  function hex4(cp) {
    if (cp <= 0xFFFF) return cp.toString(16).toUpperCase().padStart(4, "0");
    return cp.toString(16).toUpperCase().padStart(6, "0");
  }

  function codepointToString(cp) {
    try {
      return String.fromCodePoint(cp);
    } catch (e) {
      return "";
    }
  }

  function isControl(cp) {
    // C0 + DEL + C1 controls
    if (cp <= 0x1F) return true;
    if (cp === 0x7F) return true;
    if (cp >= 0x80 && cp <= 0x9F) return true;
    return false;
  }

  function isWhitespace(cp) {
    // A practical set; you can expand if you want.
    return (
      cp === 0x20 ||  // space
      cp === 0x09 ||  // tab
      cp === 0x0A ||  // LF
      cp === 0x0D ||  // CR
      cp === 0xA0 ||  // NBSP
      cp === 0x1680 ||
      (cp >= 0x2000 && cp <= 0x200A) ||
      cp === 0x2028 ||
      cp === 0x2029 ||
      cp === 0x202F ||
      cp === 0x205F ||
      cp === 0x3000
    );
  }

  function isCombining(cp) {
    // Major combining ranges
    return (
      (cp >= 0x0300 && cp <= 0x036F) ||
      (cp >= 0x1AB0 && cp <= 0x1AFF) ||
      (cp >= 0x1DC0 && cp <= 0x1DFF) ||
      (cp >= 0x20D0 && cp <= 0x20FF) ||
      (cp >= 0xFE20 && cp <= 0xFE2F)
    );
  }

  function categoryFor(cp) {
    if (isControl(cp)) return "control";
    if (isWhitespace(cp)) return "whitespace";
    if (isCombining(cp)) return "combining";
    if (cp >= 0xE000 && cp <= 0xF8FF) return "pua-bmp";
    if (cp >= 0xF0000 && cp <= 0xFFFFD) return "pua-plane15";
    if (cp >= 0x100000 && cp <= 0x10FFFD) return "pua-plane16";
    return "symbol";
  }

  function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).toUpperCase().padStart(2, "0")).join(" ");
  }

  function utf8BytesForString(s) {
    const enc = new TextEncoder();
    return enc.encode(s);
  }

  function jsEscapeFor(cp) {
    if (cp <= 0xFFFF) return "\\u" + cp.toString(16).toUpperCase().padStart(4, "0");
    return "\\u{" + cp.toString(16).toUpperCase() + "}";
  }

  function pyEscapeFor(cp) {
    if (cp <= 0xFFFF) return "\\u" + cp.toString(16).toUpperCase().padStart(4, "0");
    return "\\U" + cp.toString(16).toUpperCase().padStart(8, "0");
  }

  function htmlEntityFor(cp) {
    return "&#x" + cp.toString(16).toUpperCase() + ";";
  }

  function toast(msg) {
    const t = els.toast;
    t.textContent = msg;
    t.classList.add("show");
    window.clearTimeout(toast._timer);
    toast._timer = window.setTimeout(() => t.classList.remove("show"), 1400);
  }

  function sha1Hex(buffer) {
    // Used only for a font fingerprint in localStorage keying.
    // Falls back if SubtleCrypto isn't available (rare in modern Chrome).
    if (!crypto || !crypto.subtle) {
      let h = 2166136261 >>> 0;
      const u8 = new Uint8Array(buffer);
      for (let i = 0; i < u8.length; i++) {
        h ^= u8[i];
        h = Math.imul(h, 16777619);
      }
      return Promise.resolve("fnv1a_" + (h >>> 0).toString(16));
    }
    return crypto.subtle.digest("SHA-1", buffer).then(d => {
      const u8 = new Uint8Array(d);
      return Array.from(u8).map(b => b.toString(16).padStart(2, "0")).join("");
    });
  }

  // ---------------------------
  // Minimal TTF cmap parser (format 4 + 12)
  // ---------------------------
  class Bin {
    constructor(buffer) {
      this.dv = new DataView(buffer);
      this.u8 = new Uint8Array(buffer);
      this.len = buffer.byteLength;
    }
    u16(off) { return this.dv.getUint16(off, false); }
    i16(off) { return this.dv.getInt16(off, false); }
    u32(off) { return this.dv.getUint32(off, false); }
    tag(off) {
      return String.fromCharCode(
        this.u8[off], this.u8[off + 1], this.u8[off + 2], this.u8[off + 3]
      );
    }
  }

  function parseTTF_cmap_codepoints(buffer) {
    // Returns a Set<number> of Unicode codepoints supported by cmap
    const bin = new Bin(buffer);

    if (bin.len < 12) throw new Error("File too small to be a TTF/OTF.");

    // Offset table
    const numTables = bin.u16(4);
    const tableDir = 12;

    let cmapOff = -1;
    let cmapLen = -1;

    for (let i = 0; i < numTables; i++) {
      const rec = tableDir + i * 16;
      const tag = bin.tag(rec + 0);
      const offset = bin.u32(rec + 8);
      const length = bin.u32(rec + 12);
      if (tag === "cmap") {
        cmapOff = offset;
        cmapLen = length;
        break;
      }
    }
    if (cmapOff < 0) throw new Error("No 'cmap' table found.");

    const cmapVersion = bin.u16(cmapOff + 0);
    const numSubtables = bin.u16(cmapOff + 2);
    if (cmapVersion !== 0) {
      // Usually 0, but tolerate
    }

    // Choose best subtable: prefer Unicode full (format 12), then BMP (format 4)
    const candidates = [];
    for (let i = 0; i < numSubtables; i++) {
      const st = cmapOff + 4 + i * 8;
      const platformID = bin.u16(st + 0);
      const encodingID = bin.u16(st + 2);
      const subOff = bin.u32(st + 4);
      const subtableOff = cmapOff + subOff;

      const format = bin.u16(subtableOff + 0);
      // Unicode platform: 0; Windows: 3
      // encodingId hints: Windows 1 = Unicode BMP, 10 = Unicode full
      const score = (
        (format === 12 ? 100 : 0) +
        (format === 4 ? 80 : 0) +
        (platformID === 0 ? 20 : 0) +
        (platformID === 3 ? 10 : 0) +
        (encodingID === 10 ? 20 : 0) +
        (encodingID === 1 ? 10 : 0)
      );

      candidates.push({ platformID, encodingID, format, subtableOff, score });
    }
    candidates.sort((a, b) => b.score - a.score);

    const cps = new Set();

    let usedAny = false;
    for (let c = 0; c < candidates.length; c++) {
      const cand = candidates[c];
      const off = cand.subtableOff;
      const format = cand.format;

      if (format === 12) {
        // Format 12: u16 format, u16 reserved, u32 length, u32 language, u32 nGroups
        const nGroups = bin.u32(off + 12);
        let p = off + 16;
        for (let g = 0; g < nGroups; g++) {
          const startCharCode = bin.u32(p + 0);
          const endCharCode = bin.u32(p + 4);
          // const startGlyphID = bin.u32(p + 8);
          for (let cp = startCharCode; cp <= endCharCode; cp++) {
            cps.add(cp);
          }
          p += 12;
        }
        usedAny = true;
        break; // format 12 is best; stop
      }

      if (format === 4) {
        // Format 4: segment mapping to delta values
        // u16 format, u16 length, u16 language, u16 segCountX2, u16 searchRange, u16 entrySelector, u16 rangeShift
        const segCount = bin.u16(off + 6) / 2;
        const endCodesOff = off + 14;
        const startCodesOff = endCodesOff + 2 + segCount * 2;
        const idDeltaOff = startCodesOff + segCount * 2;
        const idRangeOffsetOff = idDeltaOff + segCount * 2;

        for (let i = 0; i < segCount; i++) {
          const endCode = bin.u16(endCodesOff + i * 2);
          const startCode = bin.u16(startCodesOff + i * 2);

          // Segment 0xFFFF/0xFFFF is the terminator
          if (startCode === 0xFFFF && endCode === 0xFFFF) continue;

          for (let cp = startCode; cp <= endCode; cp++) {
            cps.add(cp);
          }
        }
        usedAny = true;
        // Don't break; a later format 12 might exist, but we already sorted by score.
        break;
      }
    }

    if (!usedAny) throw new Error("No usable cmap subtable found (need format 4 or 12).");

    return cps;
  }

  // ---------------------------
  // Rendering-based "blank" detection
  // ---------------------------
  function makeCanvas(size) {
    const c = document.createElement("canvas");
    c.width = size;
    c.height = size;
    return c;
  }

  function renderGlyphToHash(fontFamily, glyph, fontPx) {
    // Returns {sum, hash} where sum is total alpha sum, hash is a small signature
    // This is used to detect "blank" glyphs and can be used to fingerprint tofu if needed.
    const size = Math.max(48, Math.floor(fontPx * 1.8));
    const c = renderGlyphToHash._canvas || (renderGlyphToHash._canvas = makeCanvas(size));
    if (c.width !== size) { c.width = size; c.height = size; }
    const ctx = c.getContext("2d", { willReadFrequently: true });

    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = "rgba(0,0,0,0)";
    ctx.fillRect(0, 0, size, size);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.font = `${fontPx}px "${fontFamily}", monospace`;

    // Slight vertical adjustment helps some fonts.
    ctx.fillText(glyph, size / 2, size / 2 + Math.floor(fontPx * 0.06));

    const img = ctx.getImageData(0, 0, size, size).data;

    // Compute alpha sum and a coarse hash from sampling
    let sum = 0;
    let h = 2166136261 >>> 0; // fnv-ish
    const step = Math.max(1, Math.floor(size / 32));
    for (let y = 0; y < size; y += step) {
      for (let x = 0; x < size; x += step) {
        const idx = (y * size + x) * 4;
        const a = img[idx + 3];
        sum += a;
        h ^= a;
        h = Math.imul(h, 16777619);
      }
    }
    const hash = (h >>> 0).toString(16).padStart(8, "0");
    return { sum, hash };
  }

  // ---------------------------
  // DOM Elements
  // ---------------------------
  const els = {
    fontFile: document.getElementById("fontFile"),
    fontPill: document.getElementById("fontPill"),
    fontShort: document.getElementById("fontShort"),
    search: document.getElementById("search"),
    clearSearch: document.getElementById("clearSearch"),
    glyphSize: document.getElementById("glyphSize"),
    glyphSizeNum: document.getElementById("glyphSizeNum"),
    showLabels: document.getElementById("showLabels"),
    showWhitespace: document.getElementById("showWhitespace"),
    showCombining: document.getElementById("showCombining"),
    showControls: document.getElementById("showControls"),
    blockFilter: document.getElementById("blockFilter"),
    copySelected: document.getElementById("copySelected"),
    insertSelected: document.getElementById("insertSelected"),
    starSelected: document.getElementById("starSelected"),
    glyphCount: document.getElementById("glyphCount"),
    selLabel: document.getElementById("selLabel"),

    infoChar: document.getElementById("infoChar"),
    infoCode: document.getElementById("infoCode"),
    infoUtf16: document.getElementById("infoUtf16"),
    infoUtf8: document.getElementById("infoUtf8"),
    infoJs: document.getElementById("infoJs"),
    infoPy: document.getElementById("infoPy"),
    infoHtml: document.getElementById("infoHtml"),
    infoCat: document.getElementById("infoCat"),

    favCount: document.getElementById("favCount"),
    recentCount: document.getElementById("recentCount"),
    clearFavs: document.getElementById("clearFavs"),
    clearRecents: document.getElementById("clearRecents"),
    copyInfo: document.getElementById("copyInfo"),

    main: document.getElementById("main"),
    leftPane: document.getElementById("leftPane"),
    rightPane: document.getElementById("rightPane"),
    divider: document.getElementById("divider"),

    editor: document.getElementById("editor"),
    editorStats: document.getElementById("editorStats"),
    newDoc: document.getElementById("newDoc"),
    copyAll: document.getElementById("copyAll"),
    downloadText: document.getElementById("downloadText"),
    clearEditor: document.getElementById("clearEditor"),

    glyphScroller: document.getElementById("glyphScroller"),
    spacer: document.getElementById("spacer"),
    tileLayer: document.getElementById("tileLayer"),

    toast: document.getElementById("toast"),
  };

  // ---------------------------
  // App State
  // ---------------------------
  const state = {
    fontFamily: "GlyphLabFont",
    fontUrl: null,
    fontLoaded: false,
    fontName: null,
    fontFingerprint: null,

    allCodepoints: [],        // from cmap (raw)
    displayCodepoints: [],    // filtered + searched + block-filtered
    blankExcluded: true,      // we exclude blank glyphs by rendering test
    blankCache: new Map(),    // cp -> boolean (true = nonblank)
    renderHashCache: new Map(), // cp -> {sum, hash}
    tofuHash: null,           // reserved if we ever do fallback scanning

    favorites: new Set(),     // cp
    recents: [],              // list of cp

    selectedCp: null,

    // UI derived
    splitLeftPct: 25,
    glyphSizePx: 56,
    tileSizePx: 84,
    tilePad: 10,
    labelSizePx: 11,
    showLabels: true,

    // Virtualization
    columns: 1,
    totalRows: 0,
    scrollTop: 0,
    viewportH: 0,
    viewportW: 0,
    overscanRows: 2,
    rendered: new Map(), // index -> element
    rafPending: false,

    // Filter toggles
    showWhitespace: false,
    showCombining: true,
    showControls: false,

    searchQuery: "",
    blockFilter: "all",
  };

  // ---------------------------
  // localStorage keys
  // ---------------------------
  function lsKeyBase() {
    return state.fontFingerprint ? `glyphlab:${state.fontFingerprint}` : `glyphlab:__nofont__`;
  }

  function loadPrefs() {
    // global (not per font)
    try {
      const s = localStorage.getItem("glyphlab:ui");
      if (s) {
        const j = JSON.parse(s);
        if (typeof j.splitLeftPct === "number") state.splitLeftPct = clamp(j.splitLeftPct, 15, 60);
        if (typeof j.glyphSizePx === "number") state.glyphSizePx = clamp(j.glyphSizePx, 18, 140);
        if (typeof j.showLabels === "boolean") state.showLabels = j.showLabels;
        if (typeof j.showWhitespace === "boolean") state.showWhitespace = j.showWhitespace;
        if (typeof j.showCombining === "boolean") state.showCombining = j.showCombining;
        if (typeof j.showControls === "boolean") state.showControls = j.showControls;
      }
    } catch {}
  }

  function savePrefs() {
    const j = {
      splitLeftPct: state.splitLeftPct,
      glyphSizePx: state.glyphSizePx,
      showLabels: state.showLabels,
      showWhitespace: state.showWhitespace,
      showCombining: state.showCombining,
      showControls: state.showControls
    };
    try { localStorage.setItem("glyphlab:ui", JSON.stringify(j)); } catch {}
  }

  function loadFontScoped() {
    if (!state.fontFingerprint) return;
    try {
      const f = localStorage.getItem(lsKeyBase() + ":favorites");
      state.favorites = new Set(f ? JSON.parse(f) : []);
    } catch { state.favorites = new Set(); }

    try {
      const r = localStorage.getItem(lsKeyBase() + ":recents");
      state.recents = r ? JSON.parse(r) : [];
      if (!Array.isArray(state.recents)) state.recents = [];
      state.recents = state.recents.slice(0, 64);
    } catch { state.recents = []; }

    updateFavRecentCounts();
  }

  function saveFontScoped() {
    if (!state.fontFingerprint) return;
    try { localStorage.setItem(lsKeyBase() + ":favorites", JSON.stringify(Array.from(state.favorites))); } catch {}
    try { localStorage.setItem(lsKeyBase() + ":recents", JSON.stringify(state.recents.slice(0, 64))); } catch {}
    updateFavRecentCounts();
  }

  function updateFavRecentCounts() {
    els.favCount.textContent = String(state.favorites.size);
    els.recentCount.textContent = String(state.recents.length);
  }

  // ---------------------------
  // Editor insertion helpers (contenteditable)
  // ---------------------------
  function getCaretRangeFromPoint(x, y) {
    // Chrome supports caretPositionFromPoint; old WebKit had caretRangeFromPoint.
    if (document.caretPositionFromPoint) {
      const pos = document.caretPositionFromPoint(x, y);
      if (!pos) return null;
      const r = document.createRange();
      r.setStart(pos.offsetNode, pos.offset);
      r.collapse(true);
      return r;
    }
    if (document.caretRangeFromPoint) {
      return document.caretRangeFromPoint(x, y);
    }
    return null;
  }

  function insertTextAtRange(text, range) {
    if (!range) return false;
    range.deleteContents();
    const node = document.createTextNode(text);
    range.insertNode(node);
    range.setStartAfter(node);
    range.collapse(true);

    const sel = window.getSelection();
    if (sel) {
      sel.removeAllRanges();
      sel.addRange(range);
    }
    return true;
  }

  function insertTextAtCaret(text) {
    els.editor.focus();
    const sel = window.getSelection();
    if (!sel) return false;
    if (sel.rangeCount === 0) return false;
    const range = sel.getRangeAt(0);
    return insertTextAtRange(text, range);
  }

  function getEditorText() {
    // contenteditable returns markup; use innerText for plain text.
    return els.editor.innerText.replace(/\r\n/g, "\n");
  }

  function setEditorText(txt) {
    els.editor.innerText = txt;
    updateEditorStats();
  }

  function updateEditorStats() {
    const txt = getEditorText();
    const chars = txt.length;
    const lines = txt.length ? (txt.split("\n").length) : 1;
    els.editorStats.textContent = `Chars: ${chars} • Lines: ${lines}`;
  }

  // ---------------------------
  // Loading font
  // ---------------------------
  async function loadFontFromFile(file) {
    const buf = await file.arrayBuffer();
    const fingerprint = await sha1Hex(buf);
    state.fontFingerprint = fingerprint;

    // Create object URL for CSS font-face
    if (state.fontUrl) {
      try { URL.revokeObjectURL(state.fontUrl); } catch {}
    }
    const blob = new Blob([buf], { type: "font/ttf" });
    const url = URL.createObjectURL(blob);
    state.fontUrl = url;

    // Install @font-face
    installFontFace(state.fontFamily, url);

    // Parse cmap
    const cpsSet = parseTTF_cmap_codepoints(buf);
    // Keep only valid unicode scalar values (exclude surrogate range)
    const cps = Array.from(cpsSet).filter(cp => cp >= 0 && cp <= 0x10FFFF && !(cp >= 0xD800 && cp <= 0xDFFF));
    cps.sort((a, b) => a - b);

    state.allCodepoints = cps;
    state.blankCache.clear();
    state.renderHashCache.clear();
    state.selectedCp = null;

    // Derive fontName display; browsers don't expose name table easily without more parsing,
    // so use filename for now (reliable).
    state.fontName = file.name;
    state.fontLoaded = true;

    // Update UI
    els.fontPill.textContent = `Loaded: ${file.name} • ${cps.length.toLocaleString()} cmap codepoints`;
    els.fontShort.textContent = file.name.length > 18 ? file.name.slice(0, 18) + "…" : file.name;

    // Apply font to editor and glyph grid
    applyFontToUI();

    // Load per-font favorites/recents
    loadFontScoped();

    // Build display list (filters + search)
    await rebuildDisplayList();

    toast("Font loaded.");
  }

  function installFontFace(family, url) {
    let style = document.getElementById("fontFaceStyle");
    if (!style) {
      style = document.createElement("style");
      style.id = "fontFaceStyle";
      document.head.appendChild(style);
    }
    style.textContent = `
@font-face {
  font-family: "${family}";
  src: url("${url}");
  font-display: swap;
}
`;
  }

  function applyFontToUI() {
    els.editor.style.fontFamily = `"${state.fontFamily}", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
    // Make glyphs crisp-ish; not guaranteed for all fonts, but helps.
    els.editor.style.webkitFontSmoothing = "none";
    els.editor.style.textRendering = "geometricPrecision";
  }

  // ---------------------------
  // Filtering / Searching / Block ranges
  // ---------------------------
  const BLOCK_RANGES = {
    ascii: [[0x0020, 0x007E]],
    latin1: [[0x00A0, 0x00FF]],
    box: [[0x2500, 0x257F]],
    block: [[0x2580, 0x259F]],
    geom: [[0x25A0, 0x25FF]],
    braille: [[0x2800, 0x28FF]],
    misc: [[0x2600, 0x26FF]],
    pua_bmp: [[0xE000, 0xF8FF]],
    pua_p15: [[0xF0000, 0xFFFFD]],
    pua_p16: [[0x100000, 0x10FFFD]],
  };

  function cpInRanges(cp, ranges) {
    for (let i = 0; i < ranges.length; i++) {
      const r = ranges[i];
      if (cp >= r[0] && cp <= r[1]) return true;
    }
    return false;
  }

  function parseSearchQuery(q) {
    // Returns {type, ...}
    // Supported:
    // - empty
    // - "U+2588" or "2588" hex
    // - "2500-257F" (hex range)
    // - literal glyph (single char)
    // - "U+1F600" etc
    q = (q || "").trim();
    if (!q) return { type: "empty" };

    // Range like 2500-257F
    const mRange = q.match(/^U\+?([0-9A-Fa-f]{1,6})\s*-\s*U\+?([0-9A-Fa-f]{1,6})$/) || q.match(/^([0-9A-Fa-f]{1,6})\s*-\s*([0-9A-Fa-f]{1,6})$/);
    if (mRange) {
      const a = parseInt(mRange[1], 16);
      const b = parseInt(mRange[2], 16);
      if (Number.isFinite(a) && Number.isFinite(b)) {
        return { type: "range", lo: Math.min(a, b), hi: Math.max(a, b) };
      }
    }

    // Hex codepoint
    const mHex = q.match(/^U\+([0-9A-Fa-f]{1,6})$/) || q.match(/^([0-9A-Fa-f]{1,6})$/);
    if (mHex) {
      const cp = parseInt(mHex[1], 16);
      if (Number.isFinite(cp)) return { type: "single", cp };
    }

    // If they pasted a glyph (or multiple), use first codepoint
    const cps = Array.from(q);
    if (cps.length >= 1) {
      const cp = q.codePointAt(0);
      if (typeof cp === "number") return { type: "single", cp };
    }

    return { type: "unknown" };
  }

  async function isNonBlank(cp) {
    // Cache result: true = nonblank
    if (state.blankCache.has(cp)) return state.blankCache.get(cp);

    const glyph = codepointToString(cp);
    if (!glyph) {
      state.blankCache.set(cp, false);
      return false;
    }

    // Heuristic: controls are "blank" visually, but you may want them in list if enabled
    // We treat them as blank unless user toggles showControls.
    if (isControl(cp) && !state.showControls) {
      state.blankCache.set(cp, false);
      return false;
    }

    // Render test
    const { sum, hash } = renderGlyphToHash(state.fontFamily, glyph, Math.max(28, state.glyphSizePx));
    state.renderHashCache.set(cp, { sum, hash });

    // sum threshold: extremely small sums often happen for hairline glyphs; set low threshold
    const nonBlank = sum > 20;

    state.blankCache.set(cp, nonBlank);
    return nonBlank;
  }

  async function rebuildDisplayList() {
    if (!state.fontLoaded) {
      state.displayCodepoints = [];
      updateCounts();
      scheduleRender();
      return;
    }

    const q = parseSearchQuery(state.searchQuery);
    const block = state.blockFilter;

    const showWhitespace = state.showWhitespace;
    const showCombining = state.showCombining;
    const showControls = state.showControls;

    const result = [];
    const source = state.allCodepoints;

    // fast block filtering first
    let blockRanges = null;
    if (BLOCK_RANGES[block]) blockRanges = BLOCK_RANGES[block];

    for (let i = 0; i < source.length; i++) {
      const cp = source[i];

      // Block filter
      if (block === "favorites") {
        if (!state.favorites.has(cp)) continue;
      } else if (block === "recent") {
        // Keep recents order, not cmap order
        // We'll handle after loop.
      } else if (blockRanges) {
        if (!cpInRanges(cp, blockRanges)) continue;
      }

      // Search filter
      if (q.type === "single") {
        if (cp !== q.cp) continue;
      } else if (q.type === "range") {
        if (cp < q.lo || cp > q.hi) continue;
      } else if (q.type === "unknown") {
        // Treat unknown as "no match"
        continue;
      }

      // Category toggles
      if (!showControls && isControl(cp)) continue;
      if (!showWhitespace && isWhitespace(cp)) continue;
      if (!showCombining && isCombining(cp)) continue;

      // Blank filter (render test)
      const ok = await isNonBlank(cp);
      if (!ok) continue;

      result.push(cp);
    }

    if (block === "recent") {
      // Preserve recent order, but only include ones that still pass filters and exist in font.
      const filtered = [];
      const seen = new Set();
      for (let i = 0; i < state.recents.length; i++) {
        const cp = state.recents[i];
        if (seen.has(cp)) continue;
        seen.add(cp);
        if (!source.includes(cp)) continue;
        // Apply search / category / blank checks same as above
        if (q.type === "single" && cp !== q.cp) continue;
        if (q.type === "range" && (cp < q.lo || cp > q.hi)) continue;
        if (!showControls && isControl(cp)) continue;
        if (!showWhitespace && isWhitespace(cp)) continue;
        if (!showCombining && isCombining(cp)) continue;
        const ok = await isNonBlank(cp);
        if (!ok) continue;
        filtered.push(cp);
      }
      state.displayCodepoints = filtered;
    } else {
      state.displayCodepoints = result;
    }

    updateCounts();
    updateVirtualMetrics();
    scheduleRender();
  }

  function updateCounts() {
    els.glyphCount.textContent = String(state.displayCodepoints.length);
  }

  // ---------------------------
  // Virtualized grid rendering
  // ---------------------------
  function updateCSSVars() {
    // tile size depends on glyph size, label, and padding
    const labelH = state.showLabels ? (state.labelSizePx + 18) : 0;
    const tile = Math.floor(state.glyphSizePx * 1.55 + labelH + state.tilePad * 2);
    state.tileSizePx = clamp(tile, 56, 220);

    document.documentElement.style.setProperty("--glyphSize", state.glyphSizePx + "px");
    document.documentElement.style.setProperty("--tile", state.tileSizePx + "px");
    document.documentElement.style.setProperty("--labelSize", state.labelSizePx + "px");
  }

  function updateVirtualMetrics() {
    updateCSSVars();

    const sc = els.glyphScroller;
    const rect = sc.getBoundingClientRect();

    state.viewportH = rect.height;
    state.viewportW = rect.width;

    // padding in tileLayer is 10px on each side
    const innerW = Math.max(1, state.viewportW - 20);
    const col = Math.max(1, Math.floor(innerW / state.tileSizePx));
    state.columns = col;

    const total = state.displayCodepoints.length;
    const rows = Math.ceil(total / col);
    state.totalRows = rows;

    const spacerH = rows * state.tileSizePx + 20; // includes padding
    els.spacer.style.height = spacerH + "px";
  }

  function scheduleRender() {
    if (state.rafPending) return;
    state.rafPending = true;
    requestAnimationFrame(() => {
      state.rafPending = false;
      renderVisibleTiles();
    });
  }

  function renderVisibleTiles() {
    const sc = els.glyphScroller;
    const scrollTop = sc.scrollTop;
    state.scrollTop = scrollTop;

    const col = state.columns;
    const tile = state.tileSizePx;
    const total = state.displayCodepoints.length;

    const startRow = Math.max(0, Math.floor((scrollTop - 10) / tile) - state.overscanRows);
    const endRow = Math.min(state.totalRows - 1, Math.floor((scrollTop + state.viewportH) / tile) + state.overscanRows);

    const startIndex = startRow * col;
    const endIndex = Math.min(total - 1, (endRow + 1) * col - 1);

    // Remove tiles that are no longer needed
    for (const [idx, el] of state.rendered.entries()) {
      if (idx < startIndex || idx > endIndex) {
        el.remove();
        state.rendered.delete(idx);
      }
    }

    // Create/update needed tiles
    for (let idx = startIndex; idx <= endIndex; idx++) {
      if (idx < 0 || idx >= total) continue;
      const cp = state.displayCodepoints[idx];
      const row = Math.floor(idx / col);
      const c = idx % col;

      const x = 10 + c * tile;
      const y = 10 + row * tile;

      let el = state.rendered.get(idx);
      if (!el) {
        el = createTileElement(idx, cp);
        state.rendered.set(idx, el);
        els.tileLayer.appendChild(el);
      } else {
        // Update cp if necessary (rare, if display list changed but index reused)
        if (Number(el.dataset.cp) !== cp) {
          el.dataset.cp = String(cp);
          updateTileContent(el, cp);
        }
      }

      el.style.transform = `translate(${x}px, ${y}px)`;
      const isSel = (state.selectedCp === cp);
      el.classList.toggle("selected", isSel);
      const star = el.querySelector(".star");
      if (star) star.classList.toggle("on", state.favorites.has(cp));
    }
  }

  function createTileElement(idx, cp) {
    const el = document.createElement("div");
    el.className = "tile";
    el.draggable = true;
    el.dataset.idx = String(idx);
    el.dataset.cp = String(cp);

    const star = document.createElement("div");
    star.className = "star" + (state.favorites.has(cp) ? " on" : "");
    star.textContent = "★";
    star.title = "Favorite (click star)";
    el.appendChild(star);

    const g = document.createElement("div");
    g.className = "glyph";
    g.style.fontFamily = `"${state.fontFamily}", monospace`;
    g.style.webkitFontSmoothing = "none";
    g.style.textRendering = "geometricPrecision";
    el.appendChild(g);

    const lab = document.createElement("div");
    lab.className = "glabel mono";
    el.appendChild(lab);

    updateTileContent(el, cp);

    // Click select
    el.addEventListener("click", (ev) => {
      const target = ev.target;
      if (target && target.classList && target.classList.contains("star")) {
        toggleFavorite(cp);
        ev.stopPropagation();
        return;
      }
      selectCp(cp);
    });

    // Double click insert
    el.addEventListener("dblclick", () => {
      insertCp(cp);
    });

    // Drag
    el.addEventListener("dragstart", (ev) => {
      const glyph = codepointToString(cp);
      if (!glyph) return;
      ev.dataTransfer.setData("text/plain", glyph);
      ev.dataTransfer.effectAllowed = "copy";
      selectCp(cp);
    });

    return el;
  }

  function updateTileContent(el, cp) {
    const glyph = codepointToString(cp);
    const g = el.querySelector(".glyph");
    const lab = el.querySelector(".glabel");

    if (g) g.textContent = glyph;

    if (lab) {
      if (state.showLabels) {
        lab.style.display = "inline-flex";
        lab.textContent = "U+" + hex4(cp);
      } else {
        lab.style.display = "none";
      }
    }
  }

  // ---------------------------
  // Selection + info panel
  // ---------------------------
  function selectCp(cp) {
    state.selectedCp = cp;
    els.selLabel.textContent = cp == null ? "—" : ("U+" + hex4(cp));
    updateInfoPanel(cp);
    scheduleRender(); // to update selection visuals
  }

  function updateInfoPanel(cp) {
    if (cp == null) {
      els.infoChar.textContent = "—";
      els.infoCode.textContent = "—";
      els.infoUtf16.textContent = "—";
      els.infoUtf8.textContent = "—";
      els.infoJs.textContent = "—";
      els.infoPy.textContent = "—";
      els.infoHtml.textContent = "—";
      els.infoCat.textContent = "—";
      return;
    }

    const s = codepointToString(cp);
    const utf8 = utf8BytesForString(s);
    const utf16units = [];
    for (let i = 0; i < s.length; i++) {
      utf16units.push(s.charCodeAt(i).toString(16).toUpperCase().padStart(4, "0"));
    }

    els.infoChar.textContent = s;
    els.infoCode.textContent = "U+" + hex4(cp);
    els.infoUtf16.textContent = utf16units.join(" ");
    els.infoUtf8.textContent = bytesToHex(utf8);
    els.infoJs.textContent = jsEscapeFor(cp);
    els.infoPy.textContent = pyEscapeFor(cp);
    els.infoHtml.textContent = htmlEntityFor(cp);
    els.infoCat.textContent = categoryFor(cp);
  }

  // ---------------------------
  // Favorites + Recents
  // ---------------------------
  function toggleFavorite(cp) {
    if (cp == null) return;
    if (state.favorites.has(cp)) state.favorites.delete(cp);
    else state.favorites.add(cp);
    saveFontScoped();
    scheduleRender();
  }

  function pushRecent(cp) {
    if (cp == null) return;
    // Move to front
    const idx = state.recents.indexOf(cp);
    if (idx >= 0) state.recents.splice(idx, 1);
    state.recents.unshift(cp);
    state.recents = state.recents.slice(0, 64);
    saveFontScoped();
  }

  // ---------------------------
  // Insert / Copy
  // ---------------------------
  function insertCp(cp) {
    if (cp == null) return;
    const glyph = codepointToString(cp);
    if (!glyph) return;
    const ok = insertTextAtCaret(glyph);
    if (ok) {
      pushRecent(cp);
      toast(`Inserted ${"U+" + hex4(cp)}`);
      updateEditorStats();
    } else {
      toast("Couldn't insert (click in editor first).");
    }
  }

  async function copyTextToClipboard(txt) {
    try {
      await navigator.clipboard.writeText(txt);
      return true;
    } catch {
      // fallback
      try {
        const ta = document.createElement("textarea");
        ta.value = txt;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        return true;
      } catch {
        return false;
      }
    }
  }

  async function copySelectedGlyph() {
    if (state.selectedCp == null) {
      toast("No glyph selected.");
      return;
    }
    const glyph = codepointToString(state.selectedCp);
    const ok = await copyTextToClipboard(glyph);
    toast(ok ? "Copied glyph." : "Copy failed.");
  }

  async function copySelectedInfo() {
    if (state.selectedCp == null) {
      toast("No glyph selected.");
      return;
    }
    const cp = state.selectedCp;
    const s = codepointToString(cp);
    const block = [
      `Character: ${s}`,
      `Codepoint: U+${hex4(cp)}`,
      `UTF-16: ${els.infoUtf16.textContent}`,
      `UTF-8: ${els.infoUtf8.textContent}`,
      `JS: ${jsEscapeFor(cp)}`,
      `Python: ${pyEscapeFor(cp)}`,
      `HTML: ${htmlEntityFor(cp)}`,
      `Category: ${categoryFor(cp)}`
    ].join("\n");
    const ok = await copyTextToClipboard(block);
    toast(ok ? "Copied info." : "Copy failed.");
  }

  // ---------------------------
  // Editor drag/drop support
  // ---------------------------
  function setupEditorDnD() {
    const ed = els.editor;

    ed.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      ev.dataTransfer.dropEffect = "copy";
      ed.classList.add("dragOver");
    });

    ed.addEventListener("dragleave", () => {
      ed.classList.remove("dragOver");
    });

    ed.addEventListener("drop", (ev) => {
      ev.preventDefault();
      ed.classList.remove("dragOver");

      const txt = ev.dataTransfer.getData("text/plain");
      if (!txt) return;

      ed.focus();
      const r = getCaretRangeFromPoint(ev.clientX, ev.clientY);
      const ok = insertTextAtRange(txt, r || (window.getSelection() && window.getSelection().rangeCount ? window.getSelection().getRangeAt(0) : null));
      if (ok) {
        // if dropped text is a single codepoint, record recent
        const cp = txt.codePointAt(0);
        if (typeof cp === "number") pushRecent(cp);
        toast("Dropped glyph.");
        updateEditorStats();
      }
    });
  }

  // ---------------------------
  // Splitter (drag divider)
  // ---------------------------
  function setupSplitter() {
    const div = els.divider;
    let dragging = false;

    div.addEventListener("mousedown", (ev) => {
      dragging = true;
      ev.preventDefault();
      document.body.style.cursor = "col-resize";
    });

    window.addEventListener("mousemove", (ev) => {
      if (!dragging) return;
      const rect = els.main.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const pct = (x / rect.width) * 100;
      state.splitLeftPct = clamp(pct, 15, 60);
      document.documentElement.style.setProperty("--split-left", state.splitLeftPct + "%");
      els.leftPane.style.width = state.splitLeftPct + "%";
      els.divider.style.left = state.splitLeftPct + "%";
      savePrefs();
      updateVirtualMetrics();
      scheduleRender();
    });

    window.addEventListener("mouseup", () => {
      if (!dragging) return;
      dragging = false;
      document.body.style.cursor = "";
    });
  }

  // ---------------------------
  // Download editor text
  // ---------------------------
  function downloadTextFile(filename, contents) {
    const blob = new Blob([contents], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  // ---------------------------
  // Keyboard shortcuts
  // ---------------------------
  function setupShortcuts() {
    window.addEventListener("keydown", (ev) => {
      // Ctrl+S -> download
      if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === "s") {
        ev.preventDefault();
        const name = (state.fontName ? state.fontName.replace(/\.(ttf|otf|ttc)$/i, "") : "glyphlab") + ".txt";
        downloadTextFile(name, getEditorText());
        toast("Downloaded text.");
        return;
      }

      // Enter -> insert selected (when focus not in search)
      if (ev.key === "Enter" && !ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
        const active = document.activeElement;
        if (active === els.search) return;
        if (state.selectedCp != null) {
          // If focus is inside editor, let it insert newline normally.
          if (active === els.editor) return;
          ev.preventDefault();
          insertCp(state.selectedCp);
        }
      }
    });
  }

  // ---------------------------
  // Event wiring
  // ---------------------------
  function wireUI() {
    // file load
    els.fontFile.addEventListener("change", async () => {
      const file = els.fontFile.files && els.fontFile.files[0];
      if (!file) return;
      try {
        await loadFontFromFile(file);
      } catch (e) {
        console.error(e);
        toast("Failed to load font. See console.");
        els.fontPill.textContent = "Failed to load font: " + String(e && e.message ? e.message : e);
      } finally {
        // allow reloading same file
        els.fontFile.value = "";
      }
    });

    // search
    els.search.addEventListener("input", async () => {
      state.searchQuery = els.search.value;
      await rebuildDisplayList();
    });
    els.clearSearch.addEventListener("click", async () => {
      els.search.value = "";
      state.searchQuery = "";
      await rebuildDisplayList();
      els.search.focus();
    });

    // glyph size slider / num
    function setGlyphSize(n) {
      state.glyphSizePx = clamp(n, 18, 140);
      els.glyphSize.value = String(state.glyphSizePx);
      els.glyphSizeNum.value = String(state.glyphSizePx);
      savePrefs();
      // Update blank cache? We use a low threshold; keep cache, but render test is size dependent.
      // Safer: clear blankCache so "nonblank" remains accurate at new size.
      state.blankCache.clear();
      state.renderHashCache.clear();
      rebuildDisplayList();
    }
    els.glyphSize.addEventListener("input", () => setGlyphSize(parseInt(els.glyphSize.value, 10)));
    els.glyphSizeNum.addEventListener("change", () => setGlyphSize(parseInt(els.glyphSizeNum.value, 10)));

    // toggles
    els.showLabels.addEventListener("change", async () => {
      state.showLabels = !!els.showLabels.checked;
      savePrefs();
      updateVirtualMetrics();
      scheduleRender();
    });

    els.showWhitespace.addEventListener("change", async () => {
      state.showWhitespace = !!els.showWhitespace.checked;
      savePrefs();
      await rebuildDisplayList();
    });

    els.showCombining.addEventListener("change", async () => {
      state.showCombining = !!els.showCombining.checked;
      savePrefs();
      await rebuildDisplayList();
    });

    els.showControls.addEventListener("change", async () => {
      state.showControls = !!els.showControls.checked;
      savePrefs();
      await rebuildDisplayList();
    });

    // block filter
    els.blockFilter.addEventListener("change", async () => {
      state.blockFilter = els.blockFilter.value;
      await rebuildDisplayList();
    });

    // buttons
    els.copySelected.addEventListener("click", copySelectedGlyph);
    els.insertSelected.addEventListener("click", () => {
      if (state.selectedCp == null) { toast("No glyph selected."); return; }
      insertCp(state.selectedCp);
    });
    els.starSelected.addEventListener("click", () => {
      if (state.selectedCp == null) { toast("No glyph selected."); return; }
      toggleFavorite(state.selectedCp);
      toast(state.favorites.has(state.selectedCp) ? "Starred." : "Unstarred.");
    });

    els.clearFavs.addEventListener("click", async () => {
      if (!state.fontFingerprint) { toast("No font loaded."); return; }
      state.favorites.clear();
      saveFontScoped();
      await rebuildDisplayList();
      toast("Cleared favorites.");
    });

    els.clearRecents.addEventListener("click", async () => {
      if (!state.fontFingerprint) { toast("No font loaded."); return; }
      state.recents = [];
      saveFontScoped();
      await rebuildDisplayList();
      toast("Cleared recents.");
    });

    els.copyInfo.addEventListener("click", copySelectedInfo);

    // editor actions
    els.editor.addEventListener("input", updateEditorStats);

    els.newDoc.addEventListener("click", () => {
      setEditorText("");
      els.editor.focus();
      toast("New doc.");
    });

    els.copyAll.addEventListener("click", async () => {
      const ok = await copyTextToClipboard(getEditorText());
      toast(ok ? "Copied all." : "Copy failed.");
    });

    els.downloadText.addEventListener("click", () => {
      const name = (state.fontName ? state.fontName.replace(/\.(ttf|otf|ttc)$/i, "") : "glyphlab") + ".txt";
      downloadTextFile(name, getEditorText());
      toast("Downloaded text.");
    });

    els.clearEditor.addEventListener("click", () => {
      setEditorText("");
      toast("Cleared.");
      els.editor.focus();
    });

    // scroller
    els.glyphScroller.addEventListener("scroll", scheduleRender);
    window.addEventListener("resize", () => {
      updateVirtualMetrics();
      scheduleRender();
    });
  }

  // ---------------------------
  // Initialize
  // ---------------------------
  function init() {
    loadPrefs();

    // Apply prefs to UI
    document.documentElement.style.setProperty("--split-left", state.splitLeftPct + "%");
    els.leftPane.style.width = state.splitLeftPct + "%";
    els.divider.style.left = state.splitLeftPct + "%";

    state.glyphSizePx = clamp(state.glyphSizePx, 18, 140);
    els.glyphSize.value = String(state.glyphSizePx);
    els.glyphSizeNum.value = String(state.glyphSizePx);

    els.showLabels.checked = state.showLabels;
    els.showWhitespace.checked = state.showWhitespace;
    els.showCombining.checked = state.showCombining;
    els.showControls.checked = state.showControls;

    setupSplitter();
    setupEditorDnD();
    setupShortcuts();
    wireUI();

    // initial editor stats
    setEditorText("Type here… then drag or double-click glyphs from the grid on the right.");
    updateEditorStats();

    updateVirtualMetrics();
    scheduleRender();
  }

  init();

})();
</script>
</body>
</html>
