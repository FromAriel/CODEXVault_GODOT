<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UNSCII SHMUP â€” ASCII R-Type / Gradius-ish</title>
  <style>
    :root{
      --bg:#05060a;
      --panel:#0b0d14;
      --fg:#d9d9d9;
      --hud:#9cff9c;
      --warn:#ffcf5c;
      --muted:#9aa3b2;
      --border:#202435;
    }
    @font-face{
      font-family:"unscii 16-full";
      src:
        url("./unscii-16-full.ttf") format("truetype"),
        local("unscii 16-full"),
        local("unscii-16-full");
      font-weight:normal;
      font-style:normal;
      font-display:swap;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      overflow:hidden;
      font-family:
        "unscii 16-full",
        "unscii",
        "unscii 16",
        "Noto Sans Mono",
        "Noto Mono",
        "Unifont",
        "Cascadia Mono",
        "Consolas",
        monospace;
    }
    #wrap{
      height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:12px;
      box-sizing:border-box;
    }
    #screen{
      background:#000;
      border:1px solid var(--border);
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      /* for some browsers */
      -ms-interpolation-mode:nearest-neighbor;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.03) inset;
    }
    #help{
      width:min(980px, 92vw);
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:1px solid var(--border);
      border-radius:10px;
      padding:10px 12px;
      box-sizing:border-box;
      font-size:12px;
      line-height:1.35;
      color:var(--muted);
      text-align:center;
    }
    #help b{ color:var(--hud); font-weight:700; }
    #fontStatus{ margin-top:6px; }
    .warn{ color:var(--warn); }
    #help .helpRow{ margin-top:2px; }
    #help code{
      display:inline-block;
      padding:0 4px;
      border:1px solid #2a2f44;
      border-bottom-color:#1b2032;
      border-radius:6px;
      background:var(--panel);
      color:var(--fg);
      font-family:inherit;
      font-size:12px;
      line-height:1.45;
    }
    .legendRow{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:10px;
    }
    .legendItem{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      min-width:110px;
    }
    .legendItem .label{
      color:var(--hud);
      font-weight:700;
      font-size:12px;
      letter-spacing:0.2px;
    }
    .legendItem pre{
      margin:0;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:10px;
      background:rgba(0,0,0,0.25);
      color:var(--fg);
      line-height:1.05;
      white-space:pre;
    }
    kbd{
      display:inline-block;
      padding:1px 7px;
      margin:0 2px;
      border:1px solid #2a2f44;
      border-bottom-color:#1b2032;
      border-radius:6px;
      background:var(--panel);
      color:var(--fg);
      font-family:inherit;
      font-size:12px;
      line-height:1.45;
      box-shadow: 0 1px 0 rgba(0,0,0,0.35);
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="screen" aria-label="ASCII shmup canvas"></canvas>
    <div id="help">
      <div id="helpContent"></div>
      <div id="fontStatus"></div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Core grid + UNSCII intent (8Ã—16)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const COLS = 180;
  const ROWS = 60;

  // HUD + borders
  const HUD_ROWS = 3;
  const BORDER_TOP = HUD_ROWS;          // border line row
  const BORDER_BOTTOM = ROWS - 1;       // border line row
  const PLAY_Y0 = BORDER_TOP + 1;       // inclusive
  const PLAY_Y1 = BORDER_BOTTOM - 1;    // inclusive

  const FONT_STACK =
    `"unscii 16-full","unscii-16-full","unscii","unscii 16","unscii-16","Noto Sans Mono","Noto Mono","Unifont","Cascadia Mono","Consolas",monospace`;

  const cell = { w: 8, h: 16 }; // target; we will measure & adapt if needed.

  const canvas = document.getElementById("screen");
  const ctx = canvas.getContext("2d", { alpha: false });
  const fontStatusEl = document.getElementById("fontStatus");
  const helpContentEl = document.getElementById("helpContent");

  const palette = {
    bg: "#000000",
    hud: "#9cff9c",
    dim: "#8a93a4",
    faint: "#495065",
    star1: "#2b3040",
    star2: "#434b66",
    star3: "#6a74a5",
    nebulaTeal: "rgba(108, 242, 255, 0.14)",
    nebulaPurple: "rgba(178, 141, 255, 0.14)",
    player: "#7de9ff",
    playerInv: "#c8ffff",
    option: "#ffd36e",
    bullet: "#ffe66d",
    bullet2: "#b5ff9f",
    ebullet: "#ff4d88",
    enemy1: "#ff6b6b",
    enemy2: "#ffb86b",
    enemy3: "#b28dff",
    boss: "#ff6bf7",
    bomb: "#ffcf5c",
    shield: "#6cf2ff",
    wpnSpread: "#ffe66d",
    wpnLaser: "#b5ff9f",
    wpnMissile: "#ffb86b",
    wpnCluster: "#b28dff",
    pickup: "#9cff9c",
    boom: "#ffffff",
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Helpers
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rnd = (a, b) => a + Math.random() * (b - a);
  const irnd = (a, b) => Math.floor(rnd(a, b + 1));
  const chance = (p) => Math.random() < p;
  const lerp = (a, b, t) => a + (b - a) * t;

  function codepointLen(str) {
    // counts glyphs more correctly for Unicode than .length
    return Array.from(str).length;
  }

  function spriteDims(lines) {
    let w = 0;
    for (const row of lines) w = Math.max(w, codepointLen(row));
    return { w, h: lines.length };
  }

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // Draw in grid units (cell coords)
  function drawText(x, y, text, color) {
    ctx.fillStyle = color || palette.hud;
    ctx.fillText(text, Math.round(x * cell.w), Math.round(y * cell.h));
  }

  function drawGlyph(x, y, ch, color) {
    ctx.fillStyle = color || palette.fg;
    ctx.fillText(ch, Math.round(x * cell.w), Math.round(y * cell.h));
  }

  function drawSprite(x, y, lines, color) {
    ctx.fillStyle = color;
    const ix = Math.round(x);
    const iy = Math.round(y);
    for (let r = 0; r < lines.length; r++) {
      const rowY = iy + r;
      if (rowY < 0 || rowY >= ROWS) continue;
      ctx.fillText(lines[r], ix * cell.w, rowY * cell.h);
    }
  }

  function centerX(line) {
    return Math.floor((COLS - codepointLen(line)) / 2);
  }

  function boxLines(widthInner, title) {
    const inner = widthInner;
    const top = "â•”" + "â•".repeat(inner) + "â•—";
    const midTitle = title
      ? "â•‘" + title.padEnd(inner, " ").slice(0, inner) + "â•‘"
      : null;
    const sep = "â• " + "â•".repeat(inner) + "â•£";
    const bot = "â•š" + "â•".repeat(inner) + "â•";
    return { top, midTitle, sep, bot };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ASKYBIN1 (v3) loader (boss animations)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const TEXT_DECODER = ("TextDecoder" in globalThis) ? new TextDecoder("utf-8") : null;
  const ASKY_MAGIC = [0x41, 0x53, 0x4b, 0x59, 0x42, 0x49, 0x4e, 0x31]; // ASKYBIN1

  function isGzipBytes(u8) {
    return u8 && u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
  }

  async function maybeGunzip(arrayBuffer) {
    const u8 = new Uint8Array(arrayBuffer);
    if (!isGzipBytes(u8)) return arrayBuffer;
    if (!("DecompressionStream" in globalThis)) {
      throw new Error("This browser can't gunzip .asky.gz (DecompressionStream missing).");
    }
    const ds = new DecompressionStream("gzip");
    const decompressed = new Blob([u8]).stream().pipeThrough(ds);
    return await new Response(decompressed).arrayBuffer();
  }

  function parseAskyBin1V3(arrayBuffer) {
    const u8 = new Uint8Array(arrayBuffer);
    const view = new DataView(arrayBuffer);
    let off = 0;

    const need = (n) => {
      if (off + n > u8.length) throw new Error("ASKY parse: unexpected EOF");
    };
    const readU8 = () => { need(1); return u8[off++]; };
    const readU16 = () => { need(2); const v = view.getUint16(off, true); off += 2; return v; };
    const readU32 = () => { need(4); const v = view.getUint32(off, true); off += 4; return v; };
    const readF32 = () => { need(4); const v = view.getFloat32(off, true); off += 4; return v; };
    const readBytes = (n) => { need(n); const b = u8.subarray(off, off + n); off += n; return b; };
    const readUtf8 = (n) => {
      if (!n) return "";
      const b = readBytes(n);
      if (!TEXT_DECODER) throw new Error("ASKY parse: TextDecoder not available");
      return TEXT_DECODER.decode(b);
    };
    const readUvarint = () => {
      let result = 0;
      let mul = 1;
      for (let i = 0; i < 10; i++) {
        const byte = readU8();
        result += (byte & 0x7f) * mul;
        if ((byte & 0x80) === 0) return result;
        mul *= 128;
      }
      throw new Error("ASKY parse: uvarint too long");
    };

    // Magic + version
    need(9);
    for (let i = 0; i < 8; i++) {
      if (u8[off + i] !== ASKY_MAGIC[i]) throw new Error("ASKY parse: bad magic");
    }
    off += 8;
    const version = readU8();
    if (version !== 3) throw new Error(`ASKY parse: unsupported version ${version}`);

    // HeaderV3 (36 bytes)
    const cols = readU16();
    const rows = readU16();
    const cellW = readU8();
    const cellH = readU8();
    const paletteIdWidth = readU8();
    const flags = readU8();
    const frameCount = readU32();
    const paletteCount = readU32();
    const defaultDelayMs = readU16();
    const threshold = readU8();
    const blackPoint = readU8();
    const whitePoint = readU8();
    const reserved0 = readU8();
    const gamma = readF32();
    const fontUtf8Len = readU16();
    const libraryUtf8Len = readU16();
    const keyframeInterval = readU16();
    const seekCount = readU32();

    // Strings
    const font = readUtf8(fontUtf8Len);
    const library = readUtf8(libraryUtf8Len);

    // Palette (u32 codepoints)
    const paletteGlyphs = new Array(paletteCount);
    for (let i = 0; i < paletteCount; i++) {
      const cp = readU32();
      try {
        paletteGlyphs[i] = String.fromCodePoint(cp);
      } catch {
        paletteGlyphs[i] = " ";
      }
    }

    // Seek table (frame_index, file_offset) â€” not needed for sequential decode, but parse to advance offset.
    for (let i = 0; i < seekCount; i++) {
      readU32();
      readU32();
    }

    const readPaletteId = () => {
      if (paletteIdWidth === 0) return readUvarint();
      if (paletteIdWidth === 1) return readU8();
      if (paletteIdWidth === 2) return readU16();
      if (paletteIdWidth === 4) return readU32();
      throw new Error(`ASKY parse: unsupported palette_id_width ${paletteIdWidth}`);
    };

    const decodeRow = () => {
      const runCount = readUvarint();
      const parts = [];
      let cells = 0;
      for (let r = 0; r < runCount; r++) {
        const count = readUvarint();
        const palId = readPaletteId();
        const glyph = paletteGlyphs[palId] ?? " ";
        parts.push(glyph.repeat(count));
        cells += count;
      }
      let row = parts.join("");
      if (cells < cols) row += " ".repeat(cols - cells);
      else if (cells > cols) row = Array.from(row).slice(0, cols).join("");
      return row;
    };

    const framesRows = new Array(frameCount);
    const framesMask = new Array(frameCount);
    const delaysMs = new Array(frameCount);
    let prevRows = new Array(rows).fill(" ".repeat(cols));

    const isBlankGlyph = (ch) => ch === " " || ch === "\u2800";

    const bitsetBytes = Math.ceil(rows / 8);
    for (let fi = 0; fi < frameCount; fi++) {
      const delayRaw = readUvarint();
      delaysMs[fi] = delayRaw === 0 ? defaultDelayMs : delayRaw;
      const frameFlags = readU8();
      const isKeyframe = (frameFlags & 1) !== 0;

      if (isKeyframe) {
        const rowStrings = new Array(rows);
        for (let y = 0; y < rows; y++) rowStrings[y] = decodeRow();
        framesRows[fi] = rowStrings;
        prevRows = rowStrings;
      } else {
        const changed = readBytes(bitsetBytes);
        const rowStrings = prevRows.slice();
        for (let y = 0; y < rows; y++) {
          const bi = (y / 8) | 0;
          const bit = 1 << (y & 7);
          if ((changed[bi] & bit) !== 0) rowStrings[y] = decodeRow();
        }
        framesRows[fi] = rowStrings;
        prevRows = rowStrings;
      }

      // Per-frame hitmask: 1 = solid glyph, 0 = blank/transparent.
      const mask = new Uint8Array(cols * rows);
      const rowStrings = framesRows[fi];
      for (let y = 0; y < rows; y++) {
        let x = 0;
        for (const ch of rowStrings[y]) {
          if (!isBlankGlyph(ch)) mask[(y * cols) + x] = 1;
          x++;
          if (x >= cols) break;
        }
      }
      framesMask[fi] = mask;
    }

    return {
      version,
      cols,
      rows,
      cellW,
      cellH,
      paletteIdWidth,
      flags,
      frameCount,
      paletteCount,
      defaultDelayMs,
      threshold,
      blackPoint,
      whitePoint,
      reserved0,
      gamma,
      font,
      library,
      keyframeInterval,
      seekCount,
      delaysMs,
      framesRows,
      framesMask,
    };
  }

  async function loadAskyClip(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
    const raw = await res.arrayBuffer();
    const payload = await maybeGunzip(raw);
    return parseAskyBin1V3(payload);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Font + canvas sizing
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function applyCanvasSizing() {
    const dpr = window.devicePixelRatio || 1;

    // Provisional canvas based on current cell.w/h
    canvas.width = Math.floor(COLS * cell.w * dpr);
    canvas.height = Math.floor(ROWS * cell.h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;

    ctx.font = `${cell.h}px ${FONT_STACK}`;
    ctx.textBaseline = "top";
    ctx.textAlign = "left";

    // Measure actual monospace width
    const m = ctx.measureText("M").width;
    const rounded = Math.max(6, Math.min(32, Math.round(m)));

    // If it differs, adopt the measured width so alignment stays clean even on fallback fonts.
    if (Math.abs(rounded - cell.w) >= 1) {
      cell.w = rounded;
      // Re-apply size after adopting measured width
      canvas.width = Math.floor(COLS * cell.w * dpr);
      canvas.height = Math.floor(ROWS * cell.h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      ctx.font = `${cell.h}px ${FONT_STACK}`;
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
    }

    // Fit to viewport using an integer CSS scale (keeps glyph edges sharp)
    const baseW = COLS * cell.w;
    const baseH = ROWS * cell.h;

    const pad = 24;
    const maxW = Math.max(320, window.innerWidth - pad);
    const maxH = Math.max(240, window.innerHeight - 140); // leave room for help panel

    const scaleRaw = Math.min(maxW / baseW, maxH / baseH);
    // Prefer integer scaling for crispness, but allow <1 when the grid is too large to fit.
    const scale = clamp((scaleRaw >= 1) ? Math.floor(scaleRaw) : scaleRaw, 0.25, 6);

    canvas.style.width = (baseW * scale) + "px";
    canvas.style.height = (baseH * scale) + "px";

    // Font status message
    const isTarget = (cell.w === 8 && cell.h === 16);
    const approx = (Math.abs(cell.w - 8) <= 1 && cell.h === 16);

    let msg = `Grid: ${COLS}Ã—${ROWS} â€¢ Cell: ${cell.w}Ã—${cell.h}px â€¢ Font stack: ${FONT_STACK}`;
    if (isTarget) {
      msg = `<b>UNSCII mode:</b> cell is exactly <b>8Ã—16</b>.`;
    } else if (approx) {
      msg = `<b>Near-UNSCII:</b> cell is <b>${cell.w}Ã—${cell.h}</b>. For authentic 8Ã—16, keep <code>unscii-16-full.ttf</code> next to this HTML or install â€œunscii 16-fullâ€ locally.`;
    } else {
      msg = `<span class="warn"><b>Fallback font detected:</b></span> cell is <b>${cell.w}Ã—${cell.h}</b>. Game still runs aligned, but the â€œtrueâ€ 8Ã—16 look needs <code>unscii-16-full.ttf</code> or an installed UNSCII font.`;
    }
    fontStatusEl.innerHTML = msg;
  }

  window.addEventListener("resize", applyCanvasSizing);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Sprites (grid-aligned, UNSCII-friendly glyphs)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPR_PLAYER = [
  "  â–¸â–º",
  "â•â•«â•â–º",
  "  â–¸â–º",
];
const SPR_OPTION = ["âœ¦"];

const SPR_ENEMY_SCOUT = [
  "â—„â—‚ ",
  "â—„â– â—„",
  "â—„â—ƒ ",
];

const SPR_ENEMY_BOMBER = [
  "â—¢â—£â—œâ”â•—",
  "ğŸ€âˆ™â–ˆâ–ˆâ–¶",
  "â—¥â—¤â—Ÿâ”—â•",
];

const SPR_ENEMY_TURRET = [
  " .-.",
  "( â•³ )",
  " '-'",
];

  function escapeHTML(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  }

  function spriteBlockHTML(lines) {
    return `<pre>${escapeHTML(lines.join("\n"))}</pre>`;
  }

  function updateHelpPanel() {
    if (!helpContentEl) return;

    const controls = `
      <div class="helpRow">
        <b>Controls:</b>
        <kbd>Arrows</kbd>/<kbd>WASD</kbd> move Â·
        Mouse move Â·
        <kbd>Space</kbd> fire Â·
        Left click fire Â·
        <kbd>X</kbd> bomb Â·
        Right click bomb Â·
        <kbd>E</kbd> boss Â·
        <kbd>Shift</kbd> slow Â·
        <kbd>Enter</kbd> pause Â·
        <kbd>R</kbd> restart Â·
        <kbd>C</kbd> controls Â·
        <kbd>F1</kbd> stats
      </div>
    `;

    const weapons = `
      <div class="helpRow">
        <b>Weapons:</b>
        BASIC <code>â€¢</code>/<code>â</code> Â·
        SPREAD <code>ï½¥</code> Â·
        LASER <code>----</code>/<code>====</code> Â·
        MISSILE <code>â”ˆâ”‰â³</code>/<code>â”ˆâ”‰â³â¥</code> Â·
        CLUSTER <code>â‚</code>â†’<code>â¸±</code>
      </div>
    `;

    const legendItem = (name, lines) => `
      <div class="legendItem">
        <div class="label">${escapeHTML(name)}</div>
        ${spriteBlockHTML(lines)}
      </div>
    `;

    const legend = `
      <div class="legendRow">
        ${legendItem("PLAYER", SPR_PLAYER)}
        ${legendItem("OPTION", SPR_OPTION)}
        ${legendItem("SCOUT", SPR_ENEMY_SCOUT)}
        ${legendItem("BOMBER", SPR_ENEMY_BOMBER)}
        ${legendItem("TURRET", SPR_ENEMY_TURRET)}
      </div>
    `;

    helpContentEl.innerHTML = controls + weapons + legend;
  }

  const D_PLAYER = spriteDims(SPR_PLAYER);
  const D_OPTION = spriteDims(SPR_OPTION);

  const D_SCOUT  = spriteDims(SPR_ENEMY_SCOUT);
  const D_BOMBER = spriteDims(SPR_ENEMY_BOMBER);
  const D_TURRET = spriteDims(SPR_ENEMY_TURRET);

  const BOOM_FRAMES = ["î°„", "î°ƒ", "î°…", "î°†", "î ¾", "î ½", "î†", " "];
  const PWR_FRAMES = ["î²š", "î²›", "î²œ", "î²"];
  const MAX_BOMBS = 3;
  const MAX_WEAPON_LEVEL = 3;

  const WEAPONS = ["basic", "spread", "laser", "missile", "cluster"];
  const WEAPON_NAME = {
    basic: "BASIC",
    spread: "SPREAD",
    laser: "LASER",
    missile: "MISSILE",
    cluster: "CLUSTER",
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Input
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const keys = new Set();
  let lastFireDown = false;
  let lastBombDown = false;
  let controlsPrevState = "title";
  const mouse = {
    active: false,
    x: 0,
    y: 0,
    fire: false,
  };

  function isDown(code) { return keys.has(code); }

  function updateMousePos(e) {
    const r = canvas.getBoundingClientRect();
    if (!r.width || !r.height) return;
    const nx = (e.clientX - r.left) / r.width;
    const ny = (e.clientY - r.top) / r.height;
    mouse.x = clamp(nx * COLS, 0, COLS);
    mouse.y = clamp(ny * ROWS, 0, ROWS);
  }

  window.addEventListener("keydown", (e) => {
    const code = e.code;
    keys.add(code);

    // Prevent page scroll on arrows/space.
    if (code.startsWith("Arrow") || code === "Space") e.preventDefault();

    // One-shot actions
    if (code === "KeyC") {
      if (state === "controls") state = controlsPrevState;
      else { controlsPrevState = state; state = "controls"; }
      e.preventDefault();
    }
    if (code === "Enter") {
      if (state === "title" || state === "gameover") {
        startGame();
      } else if (state === "playing") {
        state = "paused";
      } else if (state === "paused") {
        state = "playing";
      }
    }
    if (code === "KeyR") {
      resetGame();
      state = "title";
    }
    if (code === "F1") {
      debugHUD = !debugHUD;
      e.preventDefault();
    }
    if (code === "KeyE") {
      spawnTestBoss();
      e.preventDefault();
    }
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    keys.delete(e.code);
  });

  // Mouse controls on the canvas
  canvas.addEventListener("contextmenu", (e) => e.preventDefault());
  canvas.addEventListener("pointerenter", () => { mouse.active = true; });
  canvas.addEventListener("pointerleave", () => { if (!mouse.fire) mouse.active = false; });
  canvas.addEventListener("pointermove", (e) => {
    updateMousePos(e);
  });
  canvas.addEventListener("pointerdown", (e) => {
    updateMousePos(e);
    mouse.active = true;
    try { canvas.setPointerCapture(e.pointerId); } catch {}

    if (e.button === 0) {
      mouse.fire = true;
    } else if (e.button === 2) {
      if (state === "playing") detonateBomb();
    }
    e.preventDefault();
  });
  canvas.addEventListener("pointerup", (e) => {
    if (e.button === 0) mouse.fire = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
    e.preventDefault();
  });
  canvas.addEventListener("pointercancel", () => { mouse.fire = false; });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // World state
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let state = "title"; // title | playing | paused | controls | gameover

  const stars = [];
  const nebulae = [];
  const enemies = [];
  const bullets = [];
  const ebullets = [];
  const beams = []; // transient per-frame beam segments (laser)
  const explosions = [];
  const pickups = [];

  let spawnTimer = 0;
  let difficulty = 1;
  let runTime = 0;          // seconds in current run (pauses don't advance)
  let directorPhase = "INTRO";
  let wavePhase = "INTRO";
  let waveIndex = 0;
  let enemyCap = 6;
  let enemyBulletCap = 14;
  const playerBulletCap = 240;
  let screenFlash = 0;
  let laserSpark = 0;
  let spawnedSurvivability = false;
  let spawnedWeapon = false;
  let spawnedOption = false;

  const telemetry = {
    peakEnemies: 0,
    peakBullets: 0,
    peakEBullets: 0,
  };

  let debugHUD = true;

  const player = {
    x: 8,
    y: Math.floor((PLAY_Y0 + PLAY_Y1) / 2) - 1,
    vx: 0,
    vy: 0,
    speed: 22,
    lives: 3,
    bombs: 1,
    shield: 0,
    invuln: 0,
    cooldown: 0,
    weapon: "basic",
    fireLevel: 1,     // 1..3
    options: 0,       // 0..2
    optionSpacing: 14,
    trail: [],
    score: 0,
    streak: 0,
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Boss system (ASKY clips)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const TEST_BOSS_URL = "./skull.asky.gz";
  const BOSS_BOMB_DAMAGE_FRACTION = 0.18; // "significant but not overwhelming"

  let boss = null; // { state, clip, x,y,vx,targetX,yBase,frame,accMs,hp,maxHp,deathT }
  let cachedSkullClip = null;
  let cachedSkullClipPromise = null;
  let bossNotice = "";
  let bossNoticeT = 0;

  function bossBlocksSpawns() {
    return !!boss;
  }

  function bossIsTargetable() {
    return boss && (boss.state === "enter" || boss.state === "fight");
  }

  function bossGridX() {
    return boss ? Math.round(boss.x) : 0;
  }

  function bossGridY() {
    return boss ? Math.round(boss.y) : 0;
  }

  function bossHitbox() {
    if (!boss || !boss.clip) return null;
    return { x: bossGridX(), y: bossGridY(), w: boss.clip.cols, h: boss.clip.rows };
  }

  function bossSolidAt(x, y) {
    if (!bossIsTargetable()) return false;
    const clip = boss.clip;
    if (!clip || !clip.framesMask) return false;
    const bx = bossGridX();
    const by = bossGridY();
    const cx = Math.floor(x - bx);
    const cy = Math.floor(y - by);
    if (cx < 0 || cy < 0 || cx >= clip.cols || cy >= clip.rows) return false;
    const mask = clip.framesMask[boss.frame];
    return !!mask && mask[(cy * clip.cols) + cx] === 1;
  }

  function bossCircleHitsSolid(cx, cy, radius) {
    if (!bossIsTargetable() || !boss.clip || !boss.clip.framesMask) return false;
    const clip = boss.clip;
    const bx = bossGridX();
    const by = bossGridY();
    const mask = clip.framesMask[boss.frame];
    if (!mask) return false;

    const r2 = radius * radius;
    const x0Raw = Math.floor(cx - radius) - bx;
    const x1Raw = Math.floor(cx + radius) - bx;
    const y0Raw = Math.floor(cy - radius) - by;
    const y1Raw = Math.floor(cy + radius) - by;
    if (x1Raw < 0 || y1Raw < 0 || x0Raw >= clip.cols || y0Raw >= clip.rows) return false;

    const x0 = clamp(x0Raw, 0, clip.cols - 1);
    const x1 = clamp(x1Raw, 0, clip.cols - 1);
    const y0 = clamp(y0Raw, 0, clip.rows - 1);
    const y1 = clamp(y1Raw, 0, clip.rows - 1);

    for (let yy = y0; yy <= y1; yy++) {
      for (let xx = x0; xx <= x1; xx++) {
        if (mask[(yy * clip.cols) + xx] !== 1) continue;
        const wx = bx + xx;
        const wy = by + yy;
        const dx = wx - cx;
        const dy = wy - cy;
        if (dx * dx + dy * dy <= r2) return true;
      }
    }
    return false;
  }

  function findBossLaserHit(x0, yRows) {
    if (!bossIsTargetable() || !boss.clip) return null;
    const clip = boss.clip;
    const bx = bossGridX();
    const by = bossGridY();
    const startX = Math.max(Math.floor(x0), bx);
    const endX = bx + clip.cols - 1;
    if (startX > endX) return null;
    for (let x = startX; x <= endX; x++) {
      for (const y of yRows) {
        if (bossSolidAt(x, y)) return { x, y };
      }
    }
    return null;
  }

  function damageBoss(amount, hitX=null, hitY=null, big=false) {
    if (!bossIsTargetable()) return;
    boss.hp -= amount;
    if (hitX != null && hitY != null) spawnExplosion(hitX, hitY, big);
    if (boss.hp <= 0) {
      boss.hp = 0;
      boss.state = "dead";
      boss.deathT = 1.35;
      // burst of explosions across the boss body
      const hb = bossHitbox();
      if (hb) {
        for (let i = 0; i < 18; i++) {
          spawnExplosion(
            hb.x + rnd(2, Math.max(3, hb.w - 3)),
            hb.y + rnd(1, Math.max(2, hb.h - 2)),
            chance(0.6),
          );
        }
      }
      player.score += 2500;
      // clear bullets for the transition
      bullets.length = 0;
      ebullets.length = 0;
    }
  }

  function clearForBoss() {
    enemies.length = 0;
    ebullets.length = 0;
  }

  function spawnTestBoss() {
    if (state !== "playing") return;
    if (boss) return;
    clearForBoss();

    boss = {
      state: "loading",
      clip: null,
      x: COLS + 6,
      y: PLAY_Y0,
      yBase: PLAY_Y0,
      vx: -18,
      targetX: COLS - 80 - 1,
      frame: 0,
      accMs: 0,
      hp: 300,
      maxHp: 300,
      deathT: 0,
    };
    bossNotice = "Loading bossâ€¦";
    bossNoticeT = 1.2;

    const startWith = (clip) => {
      const xTarget = COLS - clip.cols - 1;
      const yBase = clamp(
        PLAY_Y0 + Math.floor(((PLAY_Y1 - PLAY_Y0 + 1) - clip.rows) / 2),
        PLAY_Y0,
        PLAY_Y1 - clip.rows + 1,
      );
      boss.clip = clip;
      boss.x = COLS + 6;
      boss.targetX = xTarget;
      boss.yBase = yBase;
      boss.y = yBase;
      boss.vx = -18;
      boss.frame = 0;
      boss.accMs = 0;
      boss.hp = boss.maxHp;
      boss.state = "enter";
      bossNotice = "BOSS INCOMING";
      bossNoticeT = 1.0;
    };

    const onErr = (err) => {
      boss = null;
      bossNotice = `Boss load failed: ${String(err && err.message ? err.message : err)}`;
      bossNoticeT = 4.0;
    };

    if (cachedSkullClip) {
      startWith(cachedSkullClip);
      return;
    }
    if (!cachedSkullClipPromise) {
      cachedSkullClipPromise = loadAskyClip(TEST_BOSS_URL)
        .then((clip) => {
          cachedSkullClip = clip;
          return clip;
        })
        .catch((err) => {
          cachedSkullClipPromise = null;
          throw err;
        });
    }
    cachedSkullClipPromise.then(startWith).catch(onErr);
  }

  function updateBoss(dt) {
    if (!boss) return;
    if (bossNoticeT > 0) bossNoticeT = Math.max(0, bossNoticeT - dt);

    if (boss.state === "loading") return;
    if (!boss.clip) return;

    if (boss.state === "enter") {
      boss.x += boss.vx * dt;
      if (boss.x <= boss.targetX) {
        boss.x = boss.targetX;
        boss.vx = 0;
        boss.state = "fight";
        // ensure a clean arena once the boss is fully on-screen
        clearForBoss();
      }
    } else if (boss.state === "fight") {
      // gentle bob
      boss.y = clamp(
        boss.yBase + Math.sin(runTime * 0.7) * 1.4,
        PLAY_Y0,
        PLAY_Y1 - boss.clip.rows + 1,
      );
    } else if (boss.state === "dead") {
      boss.deathT -= dt;
      if (boss.deathT <= 0) {
        boss = null;
        // breathing room before spawns resume
        spawnTimer = Math.max(spawnTimer, 1.15);
        return;
      }
    }

    // Animation ticks for enter/fight/dead (keeps the sprite alive during death)
    boss.accMs += dt * 1000;
    let guard = 0;
    while (boss.accMs >= boss.clip.delaysMs[boss.frame] && guard++ < 12) {
      boss.accMs -= boss.clip.delaysMs[boss.frame];
      boss.frame = (boss.frame + 1) % boss.clip.frameCount;
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Spawn director (fair ramp)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 3-phase time-based curve, tuned for readability and ~120s median first death.
  // TODO: add mild â€œrankâ€ scaling (no-hit streak / score) once bombs+shields land.
  const DIRECTOR_PHASES = [
    {
      name: "INTRO",
      t0: 0,
      t1: 25,
      diff0: 1.0,
      diff1: 1.6,
      spawn: [1.35, 1.85],
      caps: { enemies: 6, ebullets: 14 },
      mix: { scout: 1.0, bomber: 0.0, turret: 0.0 },
      bulletSpeed0: 24,
      scoutFireChance: 0.10,
      scoutFireCd: [1.6, 2.4],
      bomberFireCd: [1.4, 2.1],
      turretFireCd: [1.2, 1.9],
    },
    {
      name: "CORE",
      t0: 25,
      t1: 90,
      diff0: 1.6,
      diff1: 3.0,
      spawn: [0.90, 1.35],
      caps: { enemies: 10, ebullets: 22 },
      mix: { scout: 0.72, bomber: 0.26, turret: 0.02 },
      bulletSpeed0: 28,
      scoutFireChance: 0.14,
      scoutFireCd: [1.2, 2.0],
      bomberFireCd: [1.1, 1.8],
      turretFireCd: [0.95, 1.5],
    },
    {
      name: "PRESSURE",
      t0: 90,
      t1: 240,
      diff0: 3.0,
      diff1: 5.0,
      spawn: [0.55, 0.95],
      caps: { enemies: 14, ebullets: 30 },
      mix: { scout: 0.55, bomber: 0.30, turret: 0.15 },
      bulletSpeed0: 32,
      scoutFireChance: 0.20,
      scoutFireCd: [0.9, 1.6],
      bomberFireCd: [0.75, 1.35],
      turretFireCd: [0.65, 1.10],
    },
  ];

  function computeDirector(t, score) {
    let phase = DIRECTOR_PHASES[DIRECTOR_PHASES.length - 1];
    for (const p of DIRECTOR_PHASES) {
      if (t < p.t1) { phase = p; break; }
    }

    const phaseT = clamp((t - phase.t0) / (phase.t1 - phase.t0), 0, 1);
    let diff = lerp(phase.diff0, phase.diff1, phaseT);

    // Gentle performance nudge (kept small so the early game stays learnable).
    diff += Math.min(0.8, score / 7000);

    return {
      phase: phase.name,
      difficulty: diff,
      maxEnemies: phase.caps.enemies,
      maxEBullets: phase.caps.ebullets,
      spawnMin: phase.spawn[0],
      spawnMax: phase.spawn[1],
      mix: phase.mix,
      bulletSpeed: phase.bulletSpeed0 + diff * 1.0,
      scoutFireChance: phase.scoutFireChance,
      scoutFireCdMin: phase.scoutFireCd[0],
      scoutFireCdMax: phase.scoutFireCd[1],
      bomberFireCdMin: phase.bomberFireCd[0],
      bomberFireCdMax: phase.bomberFireCd[1],
      turretFireCdMin: phase.turretFireCd[0],
      turretFireCdMax: phase.turretFireCd[1],
    };
  }

  const NEBULA_TILES = [
    "îª¬", "îª­", "îª®", "îª¯", "îª°", "îª±", "îª²", "îª´", "îª¶", "îª·", "îª¸", "îª¹", "îªº", "îª»", "îª¾", "îª¼", "îª½",
  ];

  function makeNebula(xStart=null) {
    // Mostly 2Ã—2 / 3Ã—3; occasional 5Ã—5 â€œbig cloudâ€.
    const size = (() => {
      const r = Math.random();
      if (r < 0.55) return 2;
      if (r < 0.93) return 3;
      return 5;
    })();

    const skipChance = (size === 2) ? 0.18 : (size === 3) ? 0.25 : 0.62;
    const tiles = [];
    let filled = 0;
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        if (chance(skipChance)) continue;
        tiles.push({ x, y, ch: NEBULA_TILES[irnd(0, NEBULA_TILES.length - 1)] });
        filled++;
      }
    }
    if (filled <= 1) {
      tiles.push({ x: 0, y: 0, ch: NEBULA_TILES[irnd(0, NEBULA_TILES.length - 1)] });
      if (size === 3) tiles.push({ x: 1, y: 1, ch: NEBULA_TILES[irnd(0, NEBULA_TILES.length - 1)] });
      if (size === 5) {
        tiles.push({ x: 2, y: 2, ch: NEBULA_TILES[irnd(0, NEBULA_TILES.length - 1)] });
        tiles.push({ x: 1, y: 3, ch: NEBULA_TILES[irnd(0, NEBULA_TILES.length - 1)] });
      }
    }

    const color = chance(0.5) ? palette.nebulaTeal : palette.nebulaPurple;
    const speed = rnd(2.8, 6.0);
    const x = xStart ?? (COLS + rnd(18, 90));
    const y = rnd(PLAY_Y0, PLAY_Y1 - size + 1);
    return { x, y, size, tiles, color, speed };
  }

  function initStars() {
    stars.length = 0;
    const N = Math.round((COLS * (PLAY_Y1 - PLAY_Y0 + 1)) * 0.055);
    for (let i = 0; i < N; i++) {
      const layerPick = Math.random();
      let speed, ch, color;
      if (layerPick < 0.60) {
        speed = rnd(6, 12);
        ch = chance(0.96) ? "â¸°" : "â¸±";
        color = palette.star1;
      } else if (layerPick < 0.90) {
        speed = rnd(12, 20);
        ch = chance(0.92) ? "â¸°" : "â¸±";
        color = palette.star2;
      } else {
        speed = rnd(20, 32);
        ch = chance(0.86) ? "â¸°" : "â¸±";
        color = palette.star3;
      }
      stars.push({
        x: rnd(0, COLS - 1),
        y: rnd(PLAY_Y0, PLAY_Y1),
        speed,
        ch,
        color,
      });
    }

    nebulae.length = 0;
    // Background â€œnebulaâ€: sparse 2Ã—2 / 3Ã—3 / occasional 5Ã—5 glyph cluster.
    nebulae.push(makeNebula(rnd(COLS * 0.75, COLS * 1.35)));
  }

  function resetGame() {
    enemies.length = 0;
    bullets.length = 0;
    ebullets.length = 0;
    explosions.length = 0;
    pickups.length = 0;
    boss = null;
    bossNotice = "";
    bossNoticeT = 0;

    player.x = 8;
    player.y = Math.floor((PLAY_Y0 + PLAY_Y1) / 2) - 1;
    player.vx = 0;
    player.vy = 0;
    player.speed = 22;
    player.lives = 3;
    player.bombs = 1;
    player.shield = 0;
    player.invuln = 0;
    player.cooldown = 0;
    player.weapon = "basic";
    player.fireLevel = 1;
    player.options = 0;
    player.trail.length = 0;
    player.score = 0;
    player.streak = 0;

    runTime = 0;
    telemetry.peakEnemies = 0;
    telemetry.peakBullets = 0;
    telemetry.peakEBullets = 0;
    screenFlash = 0;
    spawnedSurvivability = false;
    spawnedWeapon = false;
    spawnedOption = false;
    lastBombDown = false;

    const dir0 = computeDirector(0, 0);
    directorPhase = dir0.phase;
    wavePhase = dir0.phase;
    waveIndex = 0;
    difficulty = dir0.difficulty;
    enemyCap = dir0.maxEnemies;
    enemyBulletCap = dir0.maxEBullets;
    // give players a small â€œbreathing windowâ€ at the start
    spawnTimer = rnd(dir0.spawnMin, dir0.spawnMax) + 0.9;
  }

  function startGame() {
    resetGame();
    state = "playing";
  }

  function spawnExplosion(x, y, big=false) {
    const count = big ? 6 : 3;
    for (let i = 0; i < count; i++) {
      explosions.push({
        x: x + rnd(-1.2, 1.2),
        y: y + rnd(-0.6, 0.6),
        frame: 0,
        t: 0,
        rate: rnd(0.04, 0.07),
      });
    }
  }

  function detonateBomb() {
    if (player.bombs <= 0) return;
    player.bombs--;
    player.streak = 0;
    player.invuln = Math.max(player.invuln, 0.6);
    screenFlash = 0.65;

    // Clear bullets (both sides)
    bullets.length = 0;
    ebullets.length = 0;

    // Wipe enemies (leave pickups); award reduced score without streak bonus.
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const cx = e.x + e.w * 0.5;
      const cy = e.y + e.h * 0.5;
      spawnExplosion(cx, cy, true);
      const base = (e.kind === "bomber" ? 70 : e.kind === "turret" ? 55 : 35);
      player.score += Math.floor(base * 0.6);
      enemies.splice(i, 1);
    }

    // Future bosses: significant (not overwhelming) bomb damage.
    if (bossIsTargetable()) {
      const dmg = Math.max(1, Math.ceil(boss.maxHp * BOSS_BOMB_DAMAGE_FRACTION));
      const hb = bossHitbox();
      damageBoss(dmg, hb ? hb.x + hb.w * 0.5 : null, hb ? hb.y + hb.h * 0.5 : null, true);
    }
  }

  function pickWeaponPickup() {
    const specials = ["spread", "laser", "missile", "cluster"];
    const choices = specials.filter(w => w !== player.weapon);
    const w = (choices.length > 0)
      ? choices[irnd(0, choices.length - 1)]
      : specials[irnd(0, specials.length - 1)];
    if (w === "spread") return "wpnSpread";
    if (w === "laser") return "wpnLaser";
    if (w === "missile") return "wpnMissile";
    return "wpnCluster";
  }

  function pickPickupType(t) {
    // OPTIONS are intentionally rare; weapon swaps show up occasionally.
    let wFire, wWeapon, wOption, wShield, wBomb;
    if (t < 60) {
      wFire = 0.53;
      wWeapon = 0.12;
      wOption = 0.05;
      wShield = 0.20;
      wBomb = 0.10;
    } else if (t < 150) {
      wFire = 0.47;
      wWeapon = 0.16;
      wOption = 0.06;
      wShield = 0.18;
      wBomb = 0.13;
    } else {
      wFire = 0.42;
      wWeapon = 0.20;
      wOption = 0.07;
      wShield = 0.16;
      wBomb = 0.15;
    }

    // Options: 2nd is much rarer; none after cap.
    if (player.options >= 2) { wFire += wOption; wOption = 0; }
    else if (player.options >= 1) { wOption *= 0.55; }

    // If already protected / stocked, push weight back into fire/weapons.
    if (player.shield > 0) { wFire += wShield; wShield = 0; }
    if (player.bombs >= MAX_BOMBS) { wFire += wBomb; wBomb = 0; }

    // If current weapon is capped, nudge toward weapon pickups instead of redundant FIRE.
    if (player.fireLevel >= MAX_WEAPON_LEVEL) {
      const shift = wFire * 0.35;
      wFire -= shift;
      wWeapon += shift;
    }

    const total = wFire + wWeapon + wOption + wShield + wBomb;
    let r = Math.random() * total;
    if ((r -= wFire) < 0) return "fire";
    if ((r -= wWeapon) < 0) return pickWeaponPickup();
    if ((r -= wOption) < 0) return "option";
    if ((r -= wShield) < 0) return "shield";
    return "bomb";
  }

  function spawnPickup(x, y, type="fire") {
    pickups.push({
      x, y,
      vx: -10,
      vy: rnd(-2, 2),
      ttl: 10,
      type,
      frame: irnd(0, PWR_FRAMES.length - 1),
      anim: 0,
    });

    if (type === "bomb" || type === "shield") spawnedSurvivability = true;
    if (type.startsWith("wpn")) spawnedWeapon = true;
    if (type === "option") spawnedOption = true;
  }

  function fireBullet(x, y, vx, vy, friendly, ch, color, damage=1, extra=null) {
    const arr = friendly ? bullets : ebullets;
    if (friendly) {
      if (arr.length >= playerBulletCap) return;
    } else {
      if (arr.length >= enemyBulletCap) return;
    }
    const b = { x, y, vx, vy, friendly, ch, color, damage, w: 1, h: 1, ttl: 5 };
    if (extra) Object.assign(b, extra);
    arr.push(b);
  }

  function weaponCooldown(weapon) {
    if (weapon === "basic") return 0.12;
    if (weapon === "spread") return 0.15;
    if (weapon === "missile") return 0.22;
    if (weapon === "cluster") return 0.22;
    return 0.12;
  }

  function killEnemyAtIndex(ei) {
    const e = enemies[ei];
    const cx = e.x + e.w * 0.5;
    const cy = e.y + e.h * 0.5;
    spawnExplosion(cx, cy, true);

    player.streak++;
    const bonus = 10 * (1 + Math.min(6, Math.floor(player.streak / 6)));
    player.score += (e.kind === "bomber" ? 70 : e.kind === "turret" ? 55 : 35) + bonus;

    if (chance(0.18)) spawnPickup(cx, cy, pickPickupType(runTime));
    enemies.splice(ei, 1);
  }

  function fireWeaponBurst(x0, y0, weapon, level, dmgMul=1) {
    const lv = clamp(level, 1, MAX_WEAPON_LEVEL);

    if (weapon === "basic") {
      const speed = (lv === 1) ? 62 : 74;
      const ch = (lv === 3) ? "â" : "â€¢";
      const dmg = (lv === 3) ? 2 : 1;
      fireBullet(x0, y0, speed, 0, true, ch, palette.bullet, dmg * dmgMul, { kind: "basic" });
      return;
    }

    if (weapon === "spread") {
      const speed = (lv === 1) ? 54 : 66;
      const pellet = "ï½¥";
      const angles = (lv === 3)
        ? [-0.36, -0.18, 0, 0.18, 0.36]
        : [-0.26, 0, 0.26];
      for (const a of angles) {
        fireBullet(
          x0,
          y0,
          Math.cos(a) * speed,
          Math.sin(a) * speed,
          true,
          pellet,
          palette.wpnSpread,
          1 * dmgMul,
          { kind: "spread" },
        );
      }
      return;
    }

    if (weapon === "missile") {
      const speed = (lv === 1) ? 44 : 56;
      const big = (lv === 3);
      const radius = big ? 5.0 : 3.2;
      const head = big ? "â¥" : "â³";
      fireBullet(
        x0,
        y0,
        speed,
        0,
        true,
        head,
        palette.wpnMissile,
        2 * dmgMul,
        { kind: "missile", big, radius, ttl: 6.4 },
      );
      return;
    }

    if (weapon === "cluster") {
      const speed = (lv === 1) ? 42 : 54;
      const fragCount = (lv === 1) ? 3 : (lv === 2) ? 5 : 9;
      const fragSpeed = (lv === 1) ? 56 : 66;
      fireBullet(
        x0,
        y0,
        speed,
        0,
        true,
        "â‚",
        palette.wpnCluster,
        1 * dmgMul,
        { kind: "clusterShell", startX: x0, splitDist: 14, fragCount, fragSpeed, ttl: 6.2 },
      );
    }
  }

  function clusterAngles(n) {
    if (n <= 3) return [-0.26, 0, 0.26];
    if (n <= 5) return [-0.42, -0.21, 0, 0.21, 0.42];
    // 9-way forward fan
    return [-0.62, -0.46, -0.31, -0.15, 0, 0.15, 0.31, 0.46, 0.62];
  }

  function splitClusterShell(shell) {
    const angles = clusterAngles(shell.fragCount);
    for (const a of angles) {
      fireBullet(
        shell.x,
        shell.y,
        Math.cos(a) * shell.fragSpeed,
        Math.sin(a) * shell.fragSpeed,
        true,
        "â¸±",
        palette.wpnCluster,
        1,
        { kind: "clusterFrag" },
      );
    }
    spawnExplosion(shell.x, shell.y, false);
  }

  function explodeMissile(missile) {
    spawnExplosion(missile.x, missile.y, true);
    const r2 = missile.radius * missile.radius;
    for (let ei = enemies.length - 1; ei >= 0; ei--) {
      const e = enemies[ei];
      const cx = e.x + e.w * 0.5;
      const cy = e.y + e.h * 0.5;
      const dx = cx - missile.x;
      const dy = cy - missile.y;
      if (dx * dx + dy * dy <= r2) {
        e.hp -= missile.damage;
        if (e.hp <= 0) killEnemyAtIndex(ei);
      }
    }

    // Boss AoE
    if (bossCircleHitsSolid(missile.x, missile.y, missile.radius)) {
      damageBoss(missile.damage, missile.x, missile.y, true);
    }
  }

  function findLaserTarget(x0, yRows) {
    let best = null; // { kind: "enemy"|"boss", idx, x, y }
    let bestX = Infinity;

    for (let i = 0; i < enemies.length; i++) {
      const e = enemies[i];
      if (e.x + e.w < x0) continue;
      let yOk = false;
      for (const y of yRows) {
        if (y >= e.y && y < e.y + e.h) { yOk = true; break; }
      }
      if (!yOk) continue;
      if (e.x < bestX) {
        bestX = e.x;
        best = { kind: "enemy", idx: i, x: e.x, y: null };
      }
    }

    const bossHit = findBossLaserHit(x0, yRows);
    if (bossHit && bossHit.x < bestX) {
      bestX = bossHit.x;
      best = { kind: "boss", idx: -1, x: bossHit.x, y: bossHit.y };
    }

    return best;
  }

  function emitLaserFrom(x0, y0, level, dt, dmgMul=1) {
    const lv = clamp(level, 1, MAX_WEAPON_LEVEL);
    const color = palette.wpnLaser;
    const dps = (lv === 1) ? 6 : 10;
    const yRows = (lv >= 3)
      ? [clamp(y0 - 1, PLAY_Y0, PLAY_Y1), clamp(y0, PLAY_Y0, PLAY_Y1), clamp(y0 + 1, PLAY_Y0, PLAY_Y1)]
      : [clamp(y0, PLAY_Y0, PLAY_Y1)];

    const target = findLaserTarget(x0, yRows);
    const hitX = target ? Math.floor(target.x) : (COLS - 2);
    const hitY = (target && target.y != null) ? target.y : y0;
    const endX = target ? Math.max(x0, hitX - 1) : hitX;

    // render beam segments (laser stops at first hit)
    for (const y of yRows) {
      const beamCh = (lv === 1) ? "-" : "=";
      const topCh = (lv >= 3) ? "Â¯" : beamCh;
      const botCh = (lv >= 3) ? "_" : beamCh;
      const ch = (lv >= 3)
        ? (y < y0 ? topCh : (y > y0 ? botCh : beamCh))
        : beamCh;

      for (let x = x0; x <= endX; x++) {
        beams.push({ x, y, ch, color });
      }
    }

    if (target) {
      const dmg = (dps * dmgMul) * dt;
      if (laserSpark <= 0) {
        laserSpark = 0.06;
        spawnExplosion(hitX, hitY, false);
      }

      if (target.kind === "enemy") {
        const e = enemies[target.idx];
        if (e) {
          e.hp -= dmg;
          if (e.hp <= 0) killEnemyAtIndex(target.idx);
        }
      } else {
        damageBoss(dmg, hitX, hitY, false);
      }
    }
  }

  function spawnEnemy(dir, kindOverride=null, yOverride=null, xOverride=null) {
    const mix = dir.mix;
    const total = mix.scout + mix.bomber + mix.turret;
    const kind = kindOverride ?? (() => {
      const r = Math.random() * total;
      return (r < mix.scout) ? "scout" :
        (r < mix.scout + mix.bomber) ? "bomber" :
        "turret";
    })();

    const diff = dir.difficulty;

    if (kind === "scout") {
      const y = (yOverride ?? rnd(PLAY_Y0, PLAY_Y1 - D_SCOUT.h + 1));
      enemies.push({
        kind: "scout",
        x: (xOverride ?? (COLS + 2)),
        y,
        baseY: y,
        vx: -rnd(12, 16) - diff * 0.6,
        vy: 0,
        hp: 1 + Math.floor(diff / 3),
        fire: rnd(dir.scoutFireCdMin, dir.scoutFireCdMax),
        phase: rnd(0, Math.PI * 2),
        amp: rnd(0.4, 2.6),
        freq: rnd(1.2, 2.2),
        w: D_SCOUT.w,
        h: D_SCOUT.h,
      });
      return;
    }

    if (kind === "bomber") {
      const y = (yOverride ?? rnd(PLAY_Y0, PLAY_Y1 - D_BOMBER.h + 1));
      enemies.push({
        kind: "bomber",
        x: (xOverride ?? (COLS + 3)),
        y,
        vx: -rnd(7, 10) - diff * 0.45,
        vy: 0,
        hp: 3 + Math.floor(diff / 2),
        fire: rnd(dir.bomberFireCdMin, dir.bomberFireCdMax),
        w: D_BOMBER.w,
        h: D_BOMBER.h,
      });
      return;
    }

    // Turret attached near top/bottom (gives a â€œstageâ€ feel)
    const atTop = chance(0.5);
    const y = (yOverride ?? (atTop ? PLAY_Y0 : (PLAY_Y1 - D_TURRET.h + 1)));
    enemies.push({
      kind: "turret",
      x: (xOverride ?? (COLS + 4)),
      y,
      vx: -rnd(5, 8) - diff * 0.35,
      vy: 0,
      hp: 2 + Math.floor(diff / 2),
      fire: rnd(dir.turretFireCdMin, dir.turretFireCdMax),
      w: D_TURRET.w,
      h: D_TURRET.h,
    });
  }

  function spawnWave(dir) {
    const slots = enemyCap - enemies.length;
    if (slots <= 0) return Math.max(0.35, rnd(dir.spawnMin, dir.spawnMax));

    if (dir.phase !== wavePhase) {
      wavePhase = dir.phase;
      waveIndex = 0;
    }
    waveIndex++;

    const spawnScoutLine = (count, stepY=5, xStep=4) => {
      const req = (count - 1) * stepY + D_SCOUT.h;
      const y0 = rnd(PLAY_Y0, PLAY_Y1 - req + 1);
      const n = Math.min(count, enemyCap - enemies.length);
      for (let i = 0; i < n; i++) {
        spawnEnemy(dir, "scout", y0 + i * stepY, COLS + 2 + i * xStep);
      }
      return n;
    };

    const spawnBomberEscort = () => {
      const stepY = 5;
      const req = (2 * stepY) + D_SCOUT.h;
      const y0 = rnd(PLAY_Y0, PLAY_Y1 - req + 1);
      spawnEnemy(dir, "scout",  y0,           COLS + 2);
      spawnEnemy(dir, "bomber", y0 + stepY,   COLS + 5);
      spawnEnemy(dir, "scout",  y0 + stepY*2, COLS + 3);
      return 3;
    };

    const spawnTurretEdge = () => {
      const atTop = (waveIndex % 2 === 0);
      const y = atTop ? PLAY_Y0 : (PLAY_Y1 - D_TURRET.h + 1);
      spawnEnemy(dir, "turret", y, COLS + 4);
      return 1;
    };

    let spawned = 0;

    if (dir.phase === "INTRO") {
      if (runTime < 8) {
        spawnEnemy(dir, "scout");
        return rnd(1.65, 2.25);
      }

      if (waveIndex % 5 === 0 && slots >= 2) {
        spawned = spawnScoutLine(2, 6, 4);
        return rnd(1.35, 1.85) + (spawned - 1) * 0.25;
      }

      spawnEnemy(dir, "scout");
      return rnd(dir.spawnMin, dir.spawnMax);
    }

    if (dir.phase === "CORE") {
      if (waveIndex < 3) {
        spawnEnemy(dir, "scout");
        return rnd(dir.spawnMin, dir.spawnMax) + 0.15;
      }

      if (waveIndex % 9 === 0 && slots >= 1) {
        spawned = spawnTurretEdge();
        return rnd(1.05, 1.45);
      }

      if (waveIndex % 7 === 0 && slots >= 3) {
        spawned = spawnBomberEscort();
        return rnd(1.25, 1.75) + 0.2;
      }

      if (waveIndex % 4 === 0 && slots >= 3) {
        spawned = spawnScoutLine(3, 5, 3);
        return rnd(dir.spawnMin, dir.spawnMax) + 0.35 + (spawned - 1) * 0.22;
      }

      if (waveIndex % 2 === 0 && slots >= 2) {
        spawned = spawnScoutLine(2, 5, 4);
        return rnd(dir.spawnMin, dir.spawnMax) + 0.2 + (spawned - 1) * 0.2;
      }

      spawnEnemy(dir, "scout");
      return rnd(dir.spawnMin, dir.spawnMax);
    }

    // PRESSURE: go back to mixed spawns, but keep caps.
    spawnEnemy(dir);
    return rnd(dir.spawnMin, dir.spawnMax);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Update
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateStars(dt) {
    for (const n of nebulae) {
      n.x -= n.speed * dt;
      if (n.x < -n.size - 4) {
        // keep them somewhat rare, but visible more often than v1
        Object.assign(n, makeNebula(COLS + rnd(18, 110)));
      }
    }

    for (const s of stars) {
      s.x -= (s.speed * dt);
      if (s.x < -1) {
        s.x = COLS + rnd(0, 12);
        s.y = rnd(PLAY_Y0, PLAY_Y1);
        // occasional twinkle
        if (chance(0.2)) s.ch = chance(0.92) ? "â¸°" : "â¸±";
      }
    }
  }

  function update(dt) {
    updateStars(dt);

    if (state !== "playing") return;

    runTime += dt;
    const dir = computeDirector(runTime, player.score);
    difficulty = dir.difficulty;
    directorPhase = dir.phase;
    enemyCap = dir.maxEnemies;
    enemyBulletCap = dir.maxEBullets;
    screenFlash = Math.max(0, screenFlash - dt * 2.6);
    laserSpark = Math.max(0, laserSpark - dt);
    beams.length = 0;
    updateBoss(dt);

    if (directorPhase !== wavePhase) {
      wavePhase = directorPhase;
      waveIndex = 0;
    }

    // Player invulnerability + cooldown
    player.invuln = Math.max(0, player.invuln - dt);
    player.cooldown = Math.max(0, player.cooldown - dt);

    // Movement
    const slow = isDown("ShiftLeft") || isDown("ShiftRight");
    const spd = player.speed * (slow ? 0.55 : 1);

    const left  = isDown("ArrowLeft")  || isDown("KeyA");
    const right = isDown("ArrowRight") || isDown("KeyD");
    const up    = isDown("ArrowUp")    || isDown("KeyW");
    const down  = isDown("ArrowDown")  || isDown("KeyS");

    const dx = (right ? 1 : 0) - (left ? 1 : 0);
    const dy = (down  ? 1 : 0) - (up   ? 1 : 0);

    // R-Type/Gradius-ish: constrained forward movement
    const minX = 2;
    const maxX = Math.floor(COLS * 0.55) - D_PLAYER.w;
    if (mouse.active) {
      const tx = clamp(mouse.x - (D_PLAYER.w * 0.5), minX, maxX);
      const ty = clamp(mouse.y - (D_PLAYER.h * 0.5), PLAY_Y0, PLAY_Y1 - D_PLAYER.h + 1);
      const step = spd * dt;
      player.x += clamp(tx - player.x, -step, step);
      player.y += clamp(ty - player.y, -step, step);
    } else {
      player.x += dx * spd * dt;
      player.y += dy * spd * dt;
    }

    player.x = clamp(player.x, minX, maxX);

    player.y = clamp(player.y, PLAY_Y0, PLAY_Y1 - D_PLAYER.h + 1);

    // Trail for OPTIONS
    player.trail.push({ x: player.x, y: player.y });
    if (player.trail.length > 300) player.trail.shift();

    // Pity timers: guarantee early survivability + first weapon swap.
    if (!spawnedSurvivability && runTime >= 18) {
      const type = (player.shield <= 0) ? "shield"
        : (player.bombs < MAX_BOMBS) ? "bomb"
        : "shield";
      spawnPickup(
        clamp(player.x + 30, 18, COLS - 8),
        clamp(player.y + 1, PLAY_Y0, PLAY_Y1),
        type,
      );
    }
    if (!spawnedWeapon && runTime >= 28) {
      spawnPickup(
        clamp(player.x + 32, 18, COLS - 8),
        clamp(player.y + rnd(-2, 2), PLAY_Y0, PLAY_Y1),
        pickWeaponPickup(),
      );
    }
    if (!spawnedOption && player.options <= 0 && runTime >= 45) {
      spawnPickup(
        clamp(player.x + 34, 18, COLS - 8),
        clamp(player.y + rnd(-3, 3), PLAY_Y0, PLAY_Y1),
        "option",
      );
    }

    // Fire (space)
    const fireDown = isDown("Space") || mouse.fire;
    // fire from nose
    const px = Math.round(player.x);
    const py = Math.round(player.y);
    const shotX = px + D_PLAYER.w;
    const shotY = py + 1;

    const OPTION_DMG_MUL = 0.75;

    if (player.weapon === "laser") {
      if (fireDown) {
        emitLaserFrom(shotX, shotY, player.fireLevel, dt, 1.0);

        for (let i = 0; i < player.options; i++) {
          const idx = player.trail.length - 1 - ((i + 1) * player.optionSpacing);
          const pos = idx >= 0 ? player.trail[idx] : { x: player.x - (i + 1) * 6, y: player.y };
          const ox = Math.round(pos.x);
          const oy = Math.round(pos.y);
          emitLaserFrom(ox + 1, oy + 0, player.fireLevel, dt, OPTION_DMG_MUL);
        }
      }
    } else if (fireDown && player.cooldown <= 0) {
      fireWeaponBurst(shotX, shotY, player.weapon, player.fireLevel, 1.0);

      // Fire from options (Gradius-ish)
      for (let i = 0; i < player.options; i++) {
        const idx = player.trail.length - 1 - ((i + 1) * player.optionSpacing);
        const pos = idx >= 0 ? player.trail[idx] : { x: player.x - (i + 1) * 6, y: player.y };
        const ox = Math.round(pos.x);
        const oy = Math.round(pos.y);
        fireWeaponBurst(ox + 1, oy + 0, player.weapon, player.fireLevel, OPTION_DMG_MUL);
      }

      player.cooldown = weaponCooldown(player.weapon);
    }

    // Bomb (X) â€” emergency screen wipe
    const bombDown = isDown("KeyX");
    if (bombDown && !lastBombDown) {
      detonateBomb();
    }

    // Spawn cadence (suppressed during boss)
    if (!bossBlocksSpawns()) {
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnTimer = spawnWave(dir);
        if (enemies.length >= enemyCap) spawnTimer = Math.max(spawnTimer, 0.35);
      }
    }

    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.x += e.vx * dt;

      if (e.kind === "scout") {
        // sine drift
        e.phase += e.freq * dt;
        e.y = e.baseY + Math.sin(e.phase) * e.amp;
        e.y = clamp(e.y, PLAY_Y0, PLAY_Y1 - e.h + 1);

        // occasional pot-shots
        e.fire -= dt;
        if (e.fire <= 0) {
          if (chance(dir.scoutFireChance)) {
            const speed = dir.bulletSpeed;
            const fromX = e.x - 1;
            const fromY = e.y + 1;
            // aim slightly toward player
            const ang = Math.atan2((player.y + 1) - (fromY), (player.x) - (fromX));
            const vx = Math.cos(ang) * speed;
            const vy = Math.sin(ang) * speed;
            fireBullet(fromX, fromY, vx, vy, false, "â—‹", palette.ebullet, 1);
          }
          e.fire = rnd(dir.scoutFireCdMin, dir.scoutFireCdMax);
        }
      } else {
        // bomber/turret: slower drift
        e.fire -= dt;
        if (e.fire <= 0) {
          const speed = dir.bulletSpeed + (e.kind === "turret" ? 6 : 2);
          const fromX = e.x - 1;
          const fromY = e.y + Math.floor(e.h / 2);
          const ang = Math.atan2((player.y + 1) - (fromY), (player.x) - (fromX));
          const vx = Math.cos(ang) * speed;
          const vy = Math.sin(ang) * speed;
          fireBullet(fromX, fromY, vx, vy, false, "â—‹", palette.ebullet, 1);
          e.fire = (e.kind === "turret")
            ? rnd(dir.turretFireCdMin, dir.turretFireCdMax)
            : rnd(dir.bomberFireCdMin, dir.bomberFireCdMax);
        }
      }

      // Despawn if fully off-screen
      if (e.x < -e.w - 2) enemies.splice(i, 1);
    }

    // Update bullets
    function updBul(arr) {
      for (let i = arr.length - 1; i >= 0; i--) {
        const b = arr[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.ttl -= dt;

        if (b.kind === "clusterShell" && (b.x - b.startX) >= b.splitDist) {
          splitClusterShell(b);
          arr.splice(i, 1);
          continue;
        }

        if (
          b.ttl <= 0 ||
          b.x < -2 || b.x > COLS + 2 ||
          b.y < PLAY_Y0 - 2 || b.y > PLAY_Y1 + 2
        ) {
          arr.splice(i, 1);
        }
      }
    }
    updBul(bullets);
    updBul(ebullets);

    telemetry.peakEnemies = Math.max(telemetry.peakEnemies, enemies.length);
    telemetry.peakBullets = Math.max(telemetry.peakBullets, bullets.length);
    telemetry.peakEBullets = Math.max(telemetry.peakEBullets, ebullets.length);

    // Update pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
      const p = pickups[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.ttl -= dt;
      p.anim += dt;
      if (p.anim >= 0.12) {
        p.anim = 0;
        p.frame = (p.frame + 1) % PWR_FRAMES.length;
      }
      // tiny bob
      p.vy += Math.sin((performance.now() / 220) + i) * 0.02;
      p.y = clamp(p.y, PLAY_Y0, PLAY_Y1);

      if (p.ttl <= 0 || p.x < -2) pickups.splice(i, 1);
    }

    // Update explosions
    for (let i = explosions.length - 1; i >= 0; i--) {
      const ex = explosions[i];
      ex.t += dt;
      if (ex.t >= ex.rate) {
        ex.t = 0;
        ex.frame++;
        if (ex.frame >= BOOM_FRAMES.length) {
          explosions.splice(i, 1);
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ collisions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Player bullets -> enemies / boss
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
      const b = bullets[bi];
      let hitSomething = false;

      if (bossSolidAt(b.x, b.y)) {
        hitSomething = true;
        if (b.kind === "missile") {
          explodeMissile(b);
        } else {
          damageBoss(b.damage, b.x, b.y, false);
        }
      } else {
        for (let ei = enemies.length - 1; ei >= 0; ei--) {
          const e = enemies[ei];
          if (aabb(b.x, b.y, 1, 1, e.x, e.y, e.w, e.h)) {
            hitSomething = true;

            if (b.kind === "missile") {
              explodeMissile(b);
            } else {
              e.hp -= b.damage;
              // hit spark
              spawnExplosion(b.x, b.y, false);
              if (e.hp <= 0) killEnemyAtIndex(ei);
            }
            break;
          }
        }
      }

      if (hitSomething) bullets.splice(bi, 1);
    }

    // Enemy bullets -> player
    if (player.invuln <= 0) {
      for (let bi = ebullets.length - 1; bi >= 0; bi--) {
        const b = ebullets[bi];
        if (aabb(b.x, b.y, 1, 1, player.x, player.y, D_PLAYER.w, D_PLAYER.h)) {
          ebullets.splice(bi, 1);
          if (player.shield > 0) {
            player.shield = 0;
            player.invuln = 0.6;
            player.streak = 0;
            spawnExplosion(player.x + 1.5, player.y + 1, false);
          } else {
            player.lives--;
            player.invuln = 2.0;
            player.streak = 0;
            spawnExplosion(player.x + 1.5, player.y + 1, true);
          }
          break;
        }
      }
    }

    // Enemy body -> player
    if (player.invuln <= 0) {
      for (let ei = enemies.length - 1; ei >= 0; ei--) {
        const e = enemies[ei];
        if (aabb(player.x, player.y, D_PLAYER.w, D_PLAYER.h, e.x, e.y, e.w, e.h)) {
          if (player.shield > 0) {
            player.shield = 0;
            player.invuln = 0.8;
            player.streak = 0;
            spawnExplosion(player.x + 1.5, player.y + 1, false);
            spawnExplosion(e.x + e.w * 0.5, e.y + e.h * 0.5, true);
            enemies.splice(ei, 1);
          } else {
            player.lives--;
            player.invuln = 2.0;
            player.streak = 0;
            spawnExplosion(player.x + 1.5, player.y + 1, true);
            // destroy the enemy too
            spawnExplosion(e.x + e.w * 0.5, e.y + e.h * 0.5, true);
            enemies.splice(ei, 1);
          }
          break;
        }
      }
    }

    // Boss body -> player
    if (player.invuln <= 0) {
      const hbBoss = bossHitbox();
      if (hbBoss) {
        const px = Math.round(player.x);
        const py = Math.round(player.y);
        if (aabb(px, py, D_PLAYER.w, D_PLAYER.h, hbBoss.x, hbBoss.y, hbBoss.w, hbBoss.h)) {
          const x0 = Math.max(px, hbBoss.x);
          const x1 = Math.min(px + D_PLAYER.w - 1, hbBoss.x + hbBoss.w - 1);
          const y0 = Math.max(py, hbBoss.y);
          const y1 = Math.min(py + D_PLAYER.h - 1, hbBoss.y + hbBoss.h - 1);
          let hitSolid = false;
          for (let y = y0; y <= y1 && !hitSolid; y++) {
            for (let x = x0; x <= x1; x++) {
              if (bossSolidAt(x, y)) { hitSolid = true; break; }
            }
          }

          if (hitSolid) {
            if (player.shield > 0) {
              player.shield = 0;
              player.invuln = 0.9;
              player.streak = 0;
              spawnExplosion(player.x + 1.5, player.y + 1, false);
            } else {
              player.lives--;
              player.invuln = 2.0;
              player.streak = 0;
              spawnExplosion(player.x + 1.5, player.y + 1, true);
            }
          }
        }
      }
    }

    // Pickups -> player
    for (let i = pickups.length - 1; i >= 0; i--) {
      const p = pickups[i];
      if (aabb(p.x, p.y, 1, 1, player.x, player.y, D_PLAYER.w, D_PLAYER.h)) {
        pickups.splice(i, 1);

        if (p.type === "bomb") {
          player.bombs = Math.min(MAX_BOMBS, player.bombs + 1);
          player.score += 90;
        } else if (p.type === "shield") {
          if (player.shield <= 0) player.shield = 1;
          else player.score += 60;
          player.score += 90;
        } else if (p.type === "option") {
          if (player.options < 2) player.options++;
          else player.score += 60;
          player.score += 110;
        } else if (p.type.startsWith("wpn")) {
          const newWeapon =
            (p.type === "wpnSpread") ? "spread" :
            (p.type === "wpnLaser") ? "laser" :
            (p.type === "wpnMissile") ? "missile" :
            "cluster";
          if (player.weapon !== newWeapon) {
            player.weapon = newWeapon;
            player.fireLevel = 1;
            player.cooldown = 0;
          } else {
            player.score += 80;
          }
          player.score += 140;
        } else {
          // Fire upgrade
          if (player.fireLevel < 3) player.fireLevel++;
          else player.score += 60;
          player.score += 110;
        }
        spawnExplosion(p.x, p.y, false);
      }
    }

    // Game over
    if (player.lives <= 0) {
      state = "gameover";
    }

    lastFireDown = fireDown;
    lastBombDown = bombDown;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Render
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderBorders() {
    // Top HUD separator
    const topLine = "â•š" + "â•".repeat(COLS - 2) + "â•";
    const botLine = "â•”" + "â•".repeat(COLS - 2) + "â•—";
    drawText(0, BORDER_TOP, topLine, palette.faint);
    drawText(0, BORDER_BOTTOM, botLine, palette.faint);
  }

  function formatTime(t) {
    const s = Math.max(0, Math.floor(t));
    const m = Math.floor(s / 60);
    const ss = String(s % 60).padStart(2, "0");
    return `${String(m).padStart(2, "0")}:${ss}`;
  }

  function renderHUD() {
    const lives = "â™¥".repeat(Math.max(0, player.lives));
    const opt = player.options > 0 ? ("âœ¦".repeat(player.options)) : " ";
    const level = player.fireLevel;
    const timeStr = formatTime(runTime);
    const shieldStr = player.shield > 0 ? "S" : " ";
    const wpn = WEAPON_NAME[player.weapon] || "BASIC";

    const left = `SCORE ${String(player.score).padStart(7, "0")}  `;
    const mid  = `LIVES ${lives.padEnd(6, " ")}  `;
    const right= `B ${player.bombs}/${MAX_BOMBS}  ${shieldStr}  OPTIONS ${opt.padEnd(2, " ")}  WPN ${wpn} LV ${level}  TIME ${timeStr}`;

    const line0 = (left + mid + right).padEnd(COLS, " ").slice(0, COLS);

    // streak meter
    const meterW = 22;
    const streakTier = Math.min(meterW, Math.floor(player.streak / 2));
    const meter = "â–®".repeat(streakTier) + "â–¯".repeat(meterW - streakTier);

    const line1 = (debugHUD
      ? `STREAK ${meter}  T ${timeStr}  PH ${directorPhase.padEnd(8," ")}  EN ${String(enemies.length).padStart(2,"0")}/${enemyCap}  EB ${String(ebullets.length).padStart(2,"0")}/${enemyBulletCap}  PK E${telemetry.peakEnemies} B${telemetry.peakEBullets}  DIFF ${difficulty.toFixed(1)}`
      : `STREAK ${meter}   DIFF ${Math.round(difficulty)}`
    ).padEnd(COLS, " ").slice(0, COLS);

    // help hint
    const bossHint = boss
      ? (boss.state === "loading") ? "BOSS loadingâ€¦"
        : `BOSS HP ${Math.ceil(boss.hp)}/${boss.maxHp}`
      : "";
    const line2 = (
      `Press C for controls/legend` + (bossHint ? `  â€¢  ${bossHint}` : "")
    ).padEnd(COLS, " ").slice(0, COLS);

    drawText(0, 0, line0, palette.hud);
    drawText(0, 1, line1, palette.dim);
    drawText(0, 2, line2, palette.dim);
  }

  function renderTitle() {
    const { top, sep, bot } = boxLines(72, "");
    const lines = [
      top,
      "â•‘       â‹†Â·Ëš à¼˜ *  UNSCII SHMUP  * à¼˜ ËšÂ·â‹†                                   â•‘",
      "â•‘   Râ€‘Type / Gradius / 1942 vibes â€” sideâ€‘scrolling glyph war             â•‘",
      sep,
      "â•‘   Press C for controls/legend (pauses).                                â•‘",
      "â•‘                                                                        â•‘",
      "â•‘   Powerups: FIRE Â· WEAPON Â· OPTION Â· SHIELD Â· BOMB (color-coded)       â•‘",
      "â•‘   Keep a streak for bigger score ticks.                                â•‘",
      bot,
    ];

    const y0 = 7;
    for (let i = 0; i < lines.length; i++) {
      drawText(centerX(lines[i]), y0 + i, lines[i], palette.hud);
    }

    const prompt = "â‰ª  PRESS ENTER TO LAUNCH  â‰«";
    drawText(centerX(prompt), y0 + lines.length + 3, prompt, palette.option);

    // small â€œdemo shipâ€
    drawSprite(Math.floor(COLS/2) - 14, y0 + lines.length + 6, SPR_PLAYER, palette.player);
    drawText(Math.floor(COLS/2) - 8, y0 + lines.length + 7, "â€¢â€¢â€¢", palette.bullet);
    drawSprite(Math.floor(COLS/2) + 6, y0 + lines.length + 6, SPR_ENEMY_SCOUT, palette.enemy1);
  }

  function renderOverlayText(textLines, innerW=52, y0=12) {
    // dim overlay box
    const box = boxLines(innerW, "");
    const lines = [
      box.top,
      ...textLines.map(t => "â•‘" + t.padEnd(innerW, " ").slice(0, innerW) + "â•‘"),
      box.bot,
    ];
    for (let i = 0; i < lines.length; i++) {
      drawText(centerX(lines[i]), y0 + i, lines[i], palette.hud);
    }
  }

  function renderGameOver() {
    renderOverlayText([
      "              GAME OVER               ",
      "",
      `  FINAL SCORE: ${String(player.score).padStart(7,"0")}          `,
      "",
      "  Press ENTER to restart             ",
      "  Press R to return to title         ",
    ]);
  }

  function renderPaused() {
    renderOverlayText([
      "                PAUSED               ",
      "",
      "  Press ENTER to continue            ",
      "  Press R to restart (title)         ",
    ]);
  }

  function renderControls() {
    const lines = [
      "           CONTROLS + LEGEND (C to close)           ",
      "",
      "  Move: Arrows / WASD        Slow: Shift           ",
      "  Mouse: move ship (in canvas)                     ",
      "  Fire: Space                Bomb: X              ",
      "  Fire: Left click           Bomb: Right click     ",
      "  Pause: Enter               Restart: R           ",
      "  Stats: F1   Boss test: E   Controls: C          ",
      "",
      "  Weapons (WEAPON swaps; FIRE upgrades L1â†’L3):     ",
      "  BASIC:   â€¢ / â                                     ",
      "  SPREAD:  ï½¥   (3-way â†’ 5-way)                      ",
      "  LASER:   ---- / ==== / wide (stops on first hit)  ",
      "  MISSILE: â”ˆâ”‰â³ / â”ˆâ”‰â³â¥   (AoE)                       ",
      "  CLUSTER: â‚ â†’ â¸±     (splits after distance)        ",
      "",
      "  Enemies:",
      `  SCOUT:   ${SPR_ENEMY_SCOUT[0]}`,
      `           ${SPR_ENEMY_SCOUT[1]}`,
      `           ${SPR_ENEMY_SCOUT[2]}`,
      `  BOMBER:  ${SPR_ENEMY_BOMBER[0]}`,
      `           ${SPR_ENEMY_BOMBER[1]}`,
      `           ${SPR_ENEMY_BOMBER[2]}`,
      `  TURRET:  ${SPR_ENEMY_TURRET[0]}`,
      `           ${SPR_ENEMY_TURRET[1]}`,
      `           ${SPR_ENEMY_TURRET[2]}`,
    ];
    renderOverlayText(lines, 86, 5);
  }

  function render() {
    // clear
    ctx.fillStyle = palette.bg;
    ctx.fillRect(0, 0, COLS * cell.w, ROWS * cell.h);

    // nebula backdrop
    for (const n of nebulae) {
      for (const t of n.tiles) {
        drawGlyph(n.x + t.x, n.y + t.y, t.ch, n.color);
      }
    }

    // starfield
    for (const s of stars) {
      // keep stars inside play area visually
      if (s.y < PLAY_Y0 || s.y > PLAY_Y1) continue;
      drawGlyph(s.x, s.y, s.ch, s.color);
    }

    renderHUD();
    renderBorders();

    if (state === "title") {
      renderTitle();
      return;
    }

    // boss (behind pickups/bullets for readability)
    if (boss && boss.clip) {
      const frameRows = boss.clip.framesRows[boss.frame];
      if (frameRows) drawSprite(boss.x, boss.y, frameRows, palette.boss);
    }

    if (bossNoticeT > 0 && bossNotice) {
      drawText(centerX(bossNotice), PLAY_Y0 + 1, bossNotice, palette.boss);
    }

    // pickups
    for (const p of pickups) {
      const ch = PWR_FRAMES[p.frame];
      const color =
        (p.type === "bomb") ? palette.bomb :
        (p.type === "shield") ? palette.shield :
        (p.type === "option") ? palette.option :
        (p.type === "wpnSpread") ? palette.wpnSpread :
        (p.type === "wpnLaser") ? palette.wpnLaser :
        (p.type === "wpnMissile") ? palette.wpnMissile :
        (p.type === "wpnCluster") ? palette.wpnCluster :
        palette.pickup;
      drawGlyph(p.x, p.y, ch, color);
    }

    // beams (laser)
    for (const seg of beams) {
      drawGlyph(seg.x, seg.y, seg.ch, seg.color);
    }

    // bullets
    for (const b of bullets) {
      if (b.kind === "missile") {
        if (b.big) {
          drawGlyph(b.x - 3, b.y, "â”ˆ", b.color);
          drawGlyph(b.x - 2, b.y, "â”‰", b.color);
          drawGlyph(b.x - 1, b.y, "â³", b.color);
          drawGlyph(b.x,     b.y, "â¥", b.color);
        } else {
          drawGlyph(b.x - 2, b.y, "â”ˆ", b.color);
          drawGlyph(b.x - 1, b.y, "â”‰", b.color);
          drawGlyph(b.x,     b.y, "â³", b.color);
        }
      } else {
        drawGlyph(b.x, b.y, b.ch, b.color);
      }
    }
    for (const b of ebullets) {
      drawGlyph(b.x, b.y, b.ch, b.color);
    }

    // enemies
    for (const e of enemies) {
      if (e.kind === "scout") {
        drawSprite(e.x, e.y, SPR_ENEMY_SCOUT, palette.enemy1);
      } else if (e.kind === "bomber") {
        drawSprite(e.x, e.y, SPR_ENEMY_BOMBER, palette.enemy2);
      } else {
        drawSprite(e.x, e.y, SPR_ENEMY_TURRET, palette.enemy3);
      }
    }

    // player + options
    const blink = player.invuln > 0 && (Math.floor(performance.now() / 90) % 2 === 0);
    const pColor = blink ? palette.playerInv : palette.player;

    if (player.shield > 0) {
      drawSprite(player.x - 1, player.y - 1, [
        " â•±Â¯Â¯Â¯â•² ",
        "â•±     â•²",
        "â”‚     â”‚",
        "â•²     â•±",
        " â•²â–â–â–â•± ",
      ], palette.shield);
    }
    drawSprite(player.x, player.y, SPR_PLAYER, pColor);

    // options trailing
    for (let i = 0; i < player.options; i++) {
      const idx = player.trail.length - 1 - ((i + 1) * player.optionSpacing);
      const pos = idx >= 0 ? player.trail[idx] : { x: player.x - (i + 1) * 6, y: player.y };
      drawSprite(pos.x, pos.y, SPR_OPTION, palette.option);
    }

    // explosions
    for (const ex of explosions) {
      const ch = BOOM_FRAMES[Math.min(BOOM_FRAMES.length - 1, ex.frame)];
      if (ch !== " ") drawGlyph(ex.x, ex.y, ch, palette.boom);
    }

    // screen flash (bomb)
    if (screenFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${(0.18 * screenFlash).toFixed(3)})`;
      ctx.fillRect(0, 0, COLS * cell.w, ROWS * cell.h);
    }

    if (state === "controls") renderControls();
    else if (state === "paused") renderPaused();
    else if (state === "gameover") renderGameOver();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Main loop
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let lastT = performance.now();

  function loop(t) {
    const dt = Math.min(0.033, Math.max(0, (t - lastT) / 1000));
    lastT = t;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  // Boot
  applyCanvasSizing();
  initStars();
  resetGame();
  updateHelpPanel();

  // Try resizing once fonts settle (helps if UNSCII loads late locally)
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => {
      applyCanvasSizing();
    }).catch(() => {});
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
